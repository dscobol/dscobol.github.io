[{"body":"Get the software Visit the “Download IBM Db2 Software Community Edition” at Download DB2 link.\nYou will need an IBM account to download the software. There is no cost to create an account and there is no cost to download and run the Db2 Community Edition.\nEnter all the information it needs.\nYou might have to log back in with your new IBM ID or it may take you to the next page.\nYou will be presented with some marketing stuff. Choose your options and press the Continue button.\nSince this will be installed on a Linux system, click the download link for “Linux (x64)”.\nThis will download the file “v12.1.1_linuxx64_server_dec.tar.gz”.\nIf you didn’t change anything, the default location for downloads is “~/Downloads”. This is okay.\nPrep for building the software Setup the directory structure People have different ways of setting up the structure of their home directory.\nWhen the OS was created, by default, the following directories were created:\n. ├── Desktop ├── Documents ├── Downloads ├── Music ├── Pictures ├── Public ├── Templates └── Videos Open Terminal and add three more directories, Run:\ncd mkdir bin builds dev The bin and dev directories will be useful later but for now we will focus on the builds directory.\nExtract the downloaded file Open Files and go to the Downloads folder.\nDouble click on the v12.1.1_linuxx64_server_dec.tar.gz file.\nThis will open Archive Manager.\nAfter a little while, within that, you will see “server_dec”. Click on the “Extract” button in the upper left hand corner.\nA dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory.\nWhen it is done, close the dialog box, close Archive Manager, and close Files.\nRename the directory In Terminal, Run:\ncd cd builds to go to the builds directory.\nMake sure the server_dec directory is present, Run:\nls\nRename server_dec to ibm-db2, Run:\nmv server_dec ibm-db2\nEnter the ibm-db2 directory, Run:\ncd ibm-db2\nInstall additional software In Terminal, Run the following commands to install additional software needed to run IBM DB2 LUW:\nsudo apt install build-essential sudo apt install libaio1 sudo dpkg --add-architecture i386 sudo apt install libstdc++6:i386 sudo apt install libpam0g:i386 sudo apt install ksh Checking Prerequisites Run:\n./db2prereqcheck\nIf you went with Pop!_OS, this will fail with a message about “couldn’t recognize the distribution”. Don’t worry, it should work.\nRun:\nsudo ./db2setup -f sysreq\nThis will open a small dialog window.\nClick on New Install\nMake sure DB2 Version 12.1.1 Server Editions is highlighted\nPurescale is not available on Ubuntu Click Next\nWhen you get to the window that has two buttons: Typical or Custom\nSelect Custom Check the box that you agree to the Licence Click Next When presented with “Select Features”:\nWithin Application development tools: Check “Base application development tools” Click Next Go through the rest of the windows accepting the defaults until you see “Instance Owner”.\nThe next two windows set the password for new userids: db2inst1 and db2fenc1 For the remaining windows, accept the defaults. Note: Port number is 25000. Go through the rest of the windows accepting the defaults until you see “Response File and Summary”.\nClick Finish\nThe install process will start and when it finishes, look through the log file. You might see this message:\nThe value \"DB2AUTOSTART=YES\" was set in the Profile Registry for the \"db2inst1\" instance. ERROR: An error occurred while trying to start the \"db2inst1\" instance. The return code is \"127\" and the SQL Message is: \"PROCESS_ERROR\" ERROR: An error occurred while configuring the instance \"db2inst1\". Configuring DB2 instances :.......Failure Updating global profile registry :.......Success WARNING: A minor error occurred while installing \"DB2 Server Edition \" on this computer. Some features may not function correctly. Click Finish Install additional files. Because Pop!_OS is using Ubuntu 22.04 LTS, the following files must be sym-linked into the lib64 directory:\ncd /opt/ibm/db2/V12.1/lib64 sudo ln -s awssdk/UBUNTU/22.04/libaws-cpp-sdk-core.so libaws-cpp-sdk-core.so sudo ln -s awssdk/UBUNTU/22.04/libaws-cpp-sdk-kinesis.so libaws-cpp-sdk-kinesis.so sudo ln -s awssdk/UBUNTU/22.04/libaws-cpp-sdk-s3.so libaws-cpp-sdk-s3.so sudo ln -s awssdk/UBUNTU/22.04/libaws-cpp-sdk-transfer.so libaws-cpp-sdk-transfer.so Restart the system. When it reboots, there should be three users to select from on the login window. The “normal” userid (the one created when the OS was installed), and the db2inst1 and db2fenc1 userids.\nLog in with the “normal” userid and open Terminal and Run:\ncd /opt/ibm/db2/V12.1/\nLook at the include and samples directories and make sure all the COBOL stuff is present.\n","categories":"","description":"Install the Database System","excerpt":"Install the Database System","ref":"/docs/install/ibm-db2/install-db2/","tags":"","title":"Install IBM DB2 LUW RDBMS"},{"body":"This installation: All the installation instructions were created/ran on a Pop!_OS 22.04 LTS GNU/Linux distribution.\nThe specific version used here was “pop-os_22.04_amd64_intel_53.iso”\nWill this work with other “Ubuntu based” distributions? Linux Mint. Linux Mint 21.3 (Virginia) is based on Ubuntu Jammy (22.04). This did seem to work but I did not investigate it too deeply.\nLinux Mint 22.1 (Xia) is based on Ubuntu Noble (24.04). This did not work for me.\nA number of programs have changed names with an appended “t64”.\nI don’t have the time right now to investigate how to update or adapt to the new time corrected programs.\nMS Windows WSL I have no idea.\nI don’t use MS Windows so I don’t know what it can or can not do.\n","categories":"","description":"Version v12.1.1","excerpt":"Version v12.1.1","ref":"/docs/install/ibm-db2/","tags":"","title":"Install IBM DB2-LUW"},{"body":"This site and the dscobol repositories were created because I wanted to learn how to write COBOL programs with embedded SQL Statements accessing an IBM DB2 LUW RDBMS using the GnuCOBOL compiler in a GNU/Linux environment.\nAccording to IBM’s documentation, IBM DB2 LUW will run on RedHat Enterprise or Ubuntu.\nI don’t have access to RedHat and I prefer the Pop!_OS UI over Ubuntu so I chose that.\nSo, the documentation and guides in this site are ALL for running apps and programs on Pop!_OS.\nAs an aside, this will also work in Linux Mint.\nMost of it will also apply to Ubuntu or Linux Mint but “use at your discretion”.\nNote: While all these programs have been run on Pop!_OS, GnuCOBOL is not limited to that OS.\nUsing an OS with an Ubuntu base was needed to run IBM DB2 LUW on a GNU/Linux OS.\nSee the GnuCOBOL site for more information about it’s capabilities.\n","categories":"","description":"Why does this site exist.","excerpt":"Why does this site exist.","ref":"/docs/overview/","tags":"","title":"Overview"},{"body":"What are these repositories. Within the repositories:\nCOBOL is the primary programming language. For programs that run on GNU/Linux:\nBash is the primary scripting language. For programs that run on ZOS or MVS:\nJCL is the, well, Job Control Language. For Zowe:\nIt is a combination of bash scripts and JCL. Naming Convention The ideas or concepts for the programs may have originated somewhere else(books, tutorials, other websites, etc.) but I try to “make it my own” by rewriting it using a different structure and style.\nFirst designation dsc - The code was written by dscobol(aka: me). ibm - Code from books, documentation or instruction from IBM. gem - Curtis Garvin, Steve Eckols. DB2 for the COBOL Programmer, Part 1 and 2. Murach 1991. mca - Michael Coughlan. Beginning COBOL for Programmers Apress 2014. xxx - Code from a website, blog or other source. This will be changed to reflect the source. Second designation gnu - GnuCOBOL zos - IBM Enterprise COBOL mvs - MVS COBOL zow - Zowe Framework Third and further designation A description of the focus of the programs.\nExamples: dsc-gnu-Indexed\ndsc - programs by dscobol. gnu - uses the GnuCOBOL compiler Indexed - programs that read and write to Indexed files. gem-gnu-DB2\ngem - programs from the “DB2 for the COBOL Programmer” book gnu - uses the GnuCOBOL compiler DB2 - connects to the IBM DB2 RDBMS Setting up the environment. Important Message Please read the README files within the repositories!. When setting this up, I created a certain structure for the environment that is explained (in detail) in the README.\nOther people may structure their environment differently or use a Makefile or do something else.\nIf you decide to clone or copy the repositories, please use the instructions in the README to set it up the way it is described.\nOnce it is up and running; if you want to change it up, go for it.\nBut please, get it up and running first.\n","categories":"","description":"About the [dscobol](https://github.com/dscobol) repositories.","excerpt":"About the [dscobol](https://github.com/dscobol) repositories.","ref":"/docs/about/","tags":"","title":"About"},{"body":"Install GnuCOBOL Install Build-Essential first In Terminal, Run:\nsudo apt install build-essential\nThis might be installed already or there might be some components that are missing. Better safe then sorry.\nGet GnuCOBOL Download the source code from GnuCOBOL\nAs of May 2025, the current version is 3.2\nFor that version, download: gnucobol-3.2.tar.lz.\nIf you haven’t made any changes, it will be downloaded to the Downloads directory.\nExtract the downloaded file Open Files and go to the Downloads folder.\nDouble click on the gnucobol-3.2.tar.lz file.\nThis will open Archive Manager.\nYou will see “gnucobol-3.2”. Click on the “Extract” button in the upper left hand corner.\nA dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory.\nWhen it is done, close the dialog box, close Archive Manager, and close Files.\nInstall additional software Open Terminal to install the following:\nsudo apt install libgmp-dev sudo apt install libdb5.3-dev sudo apt install libncurses-dev sudo apt install libxml2-dev sudo apt install libcjson-dev Configure, Make and Install Run:\ncd cd builds/gnucobol-3.2 This will take you into the gnucobol-3.2 directory.\nRun:\n./configure\nA whole bunch of messages will print on the screen\nAt the end, there should be some messages that look like:\nDynamic loading: System configure: Use gettext for international messages: yes configure: Use fcntl for file locking: yes configure: Use math multiple precision library: gmp configure: Use curses library for screen I/O: ncursesw configure: Use Berkeley DB for INDEXED I/O: yes configure: Used for XML I/O: libxml2 configure: Used for JSON I/O: cjson If there are no errors, Run:\nmake\nMore messages will display, if there are no errors, Run:\nmake check\nA suite of tests will run, at the end, you should see the results:\n# ------------- ## Test results. ## ------------- 1273 tests behaved as expected. 9 tests were skipped. Run:\nsudo make install\nThen Run:\nsudo ldconfig\nAs a quick test, Run:\ncobc\nYou should get an error message:\ncobc: error: no input files\nFor a better test of the install:\nCreate a new directory Create a simple COBOL program Run it. 1: Create a new directory\nIn Terminal, Run:\ncd mkdir -p ~/dev/cobol/test-cobol cd ~/dev/cobol/test-cobol touch hello.cbl 2: Create a simple COBOL program\nOpen Files, go to the dev/cobol/test-cobol folder.\nDouble-click on hello.cbl. This will open it in Text Editor.\nCopy the following code and paste it into hello.cbl:\nIDENTIFICATION DIVISION. PROGRAM-ID. SmallestProgram. DATA DIVISION. FILE SECTION. WORKING-STORAGE SECTION. PROCEDURE DIVISION. MAIN-PROCEDURE. DISPLAY \"Hello world\" STOP RUN. END PROGRAM SmallestProgram. and save it.\nGo to Terminal, Run:\npwd\nTo make sure you are in the ~/dev/cobol/test-cobol directory.\nRun:\ncobc -x hello.cbl\nIf it complies correctly(no messages), Run:\n./hello\nIt should return:\nHello world\nIf this works, delete the test-cobol directory (or not, your choice).\n","categories":"","description":"Version GnuCOBOL 3.2.0","excerpt":"Version GnuCOBOL 3.2.0","ref":"/docs/install/gnucobol/","tags":"","title":"Install GnuCOBOL."},{"body":"Check the installation In Terminal, Run:\nsu - db2inst1 ksh You will need to enter the password for db2inst1 after the su command.\nUse ksh for a “more useable” command line.\nA quick check, Run:\ndb2 list database directory\nreturns no DBs.\nValidate the install Run:\ncd sqllib/bin\nRun:\n./db2val\nThis should return: “The instance validation for the instance db2inst1 was successful.”\nInstall Sample DB While still in the sqllib/bin directory, Run:\n./db2sampl\nto create the Sample DB.\nNot sure why but this takes a LLLLOOOONNNNGGGG time to complete.\nTo check success, Run:\ndb2 list database directory\nThis should return:\nSystem Database Directory Number of entries in the directory = 1 Database 1 entry: Database alias = SAMPLE Database name = SAMPLE Local database directory = /home/db2inst1 Database release level = 16.00 Comment = Directory entry type = Indirect Catalog database partition number = 0 Alternate server hostname = Alternate server port number = Now Run:\ndb2\nThis will take you inside DB2 and provide the DB2 prompt.\nThen Run:\nconnect to sample\nThis will return:\nDatabase Connection Information Database server = DB2/LINUXX8664 12.1.1.0 SQL authorization ID = DB2INST1 Local database alias = SAMPLE Then Run:\nselect * from employee\nThis will return a listing of 42 employees\nRun:\nquit\nto exit DB2 and return to the command prompt.\nThen Run twice:\nexit\nto exit the ksh shell and exit db2inst1 and become the “normal” user again.\nInstall db2profile in .bashrc As the “normal” user, you will need to run some DB2 commands in Terminal.\nTo make this possible, add the following 4 lines to the bottom of the .bashrc file which is found in the home directory.\n# The following three lines have been added by UDB DB2. if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profile fi This will also export some very useful environment variables.\nYou will need to exit and re-open Terminal for them to be activated.\n","categories":"","description":"Install the Sample db and db2profile.","excerpt":"Install the Sample db and db2profile.","ref":"/docs/install/ibm-db2/install-sampledb/","tags":"","title":"Install the Sample DB"},{"body":"This is broken up into two areas:\n","categories":"","description":"GnuCOBOL vs ZOS COBOL","excerpt":"GnuCOBOL vs ZOS COBOL","ref":"/docs/concepts/","tags":"","title":"Concepts"},{"body":"Become Instance Owner During the install of IBM DB2 LUW, if you accepted the defaults, the Instance Owner’s userid is “db2inst1”. If you changed that, use that userid instead.\nTo create new databases, you have to become the Instance Owner and get into the DB2 system.\nRun:\nsu - db2inst1\nEnter the password.\nThis will make you “db2inst1” and display a very bare prompt\nRun:\nksh\nto get a more useable environment.\nRun:\ndb2\nThis gets you “into the DB2 system”.\nCreate a new database and call it MURACH. Because there are tables used in Murach books that have the same names as the Sample DB, create the MURACH DB.\nFollow the instructions above to “get into the db2 system”, then:\nAt the db2\u003e prompt, Run\nCREATE DATABASE MURACH\nYou might wait a very long time but it should come back with “successfully created database”\nCreate a new database and call it BOOKS. Create the BOOKS DB.\nFollow the instructions above to “get into the db2 system”, then:\nAt the db2\u003e prompt, Run\nCREATE DATABASE BOOKS\nYou might wait a very long time but it should come back with “successfully created database”\n","categories":"","description":"Create some additional DBs to be used later.","excerpt":"Create some additional DBs to be used later.","ref":"/docs/install/ibm-db2/create-db2-db/","tags":"","title":"Create a DB2 DB"},{"body":"I can’t speak about the efficiency or the scalablity or “benchmarking performance” between zOS COBOL and GnuCOBOL.\nI just don’t know.\nFrom an application programmer’s point of view though, these are the differences that I know of:\nINPUT-OUTPUT SECTION : FILE-CONTROL This is the one place where you probably need to make changes.\nThis is a snippet I copied from one of the programs I wrote a while back:\nINPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO \"../data/psap.dat.txt\" ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status. This would compile and run using GnuCOBOL.\nIf I copied this program to a zOS Mainframe, I would uncomment the first ASSIGN and ORGANIZATION lines and comment the next two and that would run on the Mainframe.\nBut, the ASSIGN statement is “hardcoded”. If the file needed to be changed, the program would have to be updated then re-compiled.\nHere is a “better, more recent version”:\nINPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO QIPSAPFILE ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status. ASSIGN statement From the GnuCOBOL documentation:\nFor example, given ASSIGN TO “DATAFILE”, the actual file name will be\nthe value of environment variable ‘DD_DATAFILE’ or the value of environment variable ‘dd_DATAFILE’ or the value of environment variable ‘DATAFILE’ or the literal “DATAFILE” So, under GNU/Linux, bash shell\nexport DD_QIPSAPFILE='../data/psap.dat.txt' ./myprog However, you cannot name it the same as the SELECT variable as that will be an error.\nOn the Mainframe, you can “get around this” by prefixing the ASSIGN variable with “DA-S-” (or other versions of this) and the compiler will parse just the last part and use that for the JCL.\nORGANIZATION statement The other change that must be made for sequential files using GnuCOBOL is the addition of the keyword “LINE”\nMainframe: ORGANIZATION IS SEQUENTIAL\nGnuCOBOL ORGANIZATION IS LINE SEQUENTIAL\nThis is because on the Mainframe, most files are a fixed length so there isn’t a “LF” or “CRLF” at the end of each line.\nFor sequential input files, the “LINE” keyword tells GnuCOBOL to examine the record, look for the line ending and strip that off before trying to process the record.\nFor sequential output files, The “LINE” keyword tells GnuCOBOL to append a line feed character at the end of each record before it writes it out.\n","categories":"","description":"Differences when running Batch programs.","excerpt":"Differences when running Batch programs.","ref":"/docs/concepts/batch/","tags":"","title":"Batch Processing"},{"body":"The Environment: The Operating System was created using the pop-os_22.04_amd64_intel_53.iso.\nThe version of IBM DB2-LUW is v12.1.1_linuxx64_server_dec.tar.gz.\nThe version of GnuCOBOL is gnucobol-3.2.tar.lz.\nA word of caution about the userid you selected as you install(ed) the OS You create a userid when you install the OS and will probably use that userid to run some db2 commands. IBM DB2 LUW has some restrictions regarding the OS userid!\nUser IDs have the following restrictions and requirements:\nMust have a primary group other than guests, admins, users, and local. Can include lowercase letters (a-z), numbers (0-9), and the underscore character (_). Cannot be longer than eight characters Cannot begin with IBM, SYS, SQL, or a number. Cannot be a DB2 reserved word (USERS, ADMINS, GUESTS, PUBLIC, or LOCAL), or an SQL reserved word. Cannot use any user IDs with root privilege for the DB2 instance ID, DAS ID, or fenced ID. Cannot include accented characters. This threw me for awhile because I wanted to use “sysop” as the userid and then the DB2 LUW install would fail.\n","categories":"","description":"How to install the various components to run COBOL on Pop!_OS.","excerpt":"How to install the various components to run COBOL on Pop!_OS.","ref":"/docs/install/","tags":"","title":"Install Software"},{"body":"zOS COBOL/DB2 vs GnuCOBOL/DB2 LUW zOS COBOL/DB2 RACF - the security system DCLGEN - Create an INCLUDE copybook member that defines the table and adds host variables. GnuCOBOL/DB2 LUW No RACF. Since there is no RACF, the DB name, the userid, and the password must be supplied to the program for it to connect to the DB. There is a db2dclgn command included with IBM DB2 LUW but it does not generate the table definition within a “EXEC SQL DECLARE” statement. It only defines the COBOL host variables. So, you have to create the EXEC SQL DECLARE “xxxxx” TABLE statement, the host variables, and the DB Connect variables within the program itself.\nDifferent methods to supply parameters A look at the examples to see the differences: Original Code from Murach book\nThis is an example of a Normal ZOS COBOL DB2 program.\nIn the repository on GitHub, this is cbl/CUSTINQ.cbl\nIt will not compile with GnuCOBOL.\nAlso, as I’m not sure about the copyright and my ability to “re-distribute” the code included in the book, this will the only time I will include the exact original code from the book. I will be using it 3 more times (Version 1, 2 and 3) but those have changes made to them to compile and run using GnuCOBOL.\nAs you will see in Versions 4 and 5, I have my own program structure and style and while the results will be the same as the original, the code will be quite different.\nVersion 1 This is an example of a Converted from ZOS to GnuCOBOL program.\nIn the repository on GitHub, this is cbl/CUSTIN1.sqb\nI started with cbl/CUSTINQ.cbl and:\nremoved the INCLUDE CUSTOMER statement\nadded the EXEC SQL DECLARE TABLE statement\nadded the host variables and the DB Connect variables\nadded Procedure code to use ACCEPT to get the userid and password from the user when the program is run.\nVersion 2 is NOT recommended. Left here for “Historical” purposes.\nVersion 2 This is an example of a Calling a Module program.\nIn the repository on GitHub, this is cbl/CUSTIN2.sqb\nI started with cbl/CUSTIN1.sqb and:\ncreated GETDBID program to “hardcode” the userid and password.\nupdated to call GETDBID and removed the ACCEPT from User code.\nupdated the Compile script to add GETDBID LLM to the compile step.\nNow the program will run without needing to ask the user for that information.\nVersion 3 This is an example of a Accept from Environment program.\nIn the repository on GitHub, this is cbl/CUSTIN3.sqb\nI started with cbl/CUSTIN2.sqb and:\ncreated a .env file with the parameters for the DB.\nremoved GETDBID program.\nupdated to ACCEPT FROM ENVIRONMENT code.\nupdated the Compile script to remove GETDBID LLM from the compile step.\nupdated the Run script to export the parameters from the .env file to the Environment Variables.\nThis program will also run without needing to ask the user for the DB parameters.\nVersion 4 is NOT recommended. Left here for “Historical” purposes.\nVersion 4 This is an example of My Version of Calling GETDBID.\nIn the repository on GitHub, this is cbl/CUSTIN4.sqb\nAs I alluded to in Version 1, this is that completely re-written program.\nEvery company has a standard and/or style that all(most?) code adheres to.\nAt some shops, it is kind of loose, at others, it is VERY rigid.\nThis is an example of getting the same result; just doing it a different way by applying a different structure to the program.\nThis is the “typical” structure I use to create new programs.\nAs I continue to add programs to the repositories, they will “follow along” with the book or tutorial or website but will be using this structure.\nVersion 5 This is an example of My Version of Accept from Environment.\nIn the repository on GitHub, this is cbl/CUSTINQ.sqb\nJust as CUSTIN2 was converted into CUSTIN3 by replacing the “CALL to GETDBID” with “ACCEPT FROM ENVIRONMENT”, this is CUSTIN4 converted into CUSTINQ the same way.\n","categories":"","description":"Differences when running DB2 programs.","excerpt":"Differences when running DB2 programs.","ref":"/docs/concepts/db2/","tags":"","title":"DB2 Processing"},{"body":" At some time in the near future ","categories":"","description":"Show your user how to work through some end to end examples.","excerpt":"Show your user how to work through some end to end examples.","ref":"/docs/tutorials/","tags":"","title":"Tutorials"},{"body":"","categories":"","description":"","excerpt":"","ref":"/blog/news/","tags":"","title":"News"},{"body":"","categories":"","description":"","excerpt":"","ref":"/blog/releases/","tags":"","title":"Releases"},{"body":" IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. * EXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC. * PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM MM01.CUSTOMER WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * This is the code from the WORKING-STORAGE SECTION.\nEXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC. Notes about this code: Within “INCLUDE CUSTOMER”, CUSTOMER is the DCLGEN generated copybook member\n“CUSTOMER” has two areas: A “EXEC SQL DECLARE CUSTOMER TABLE area which lists each column name and data type in the table BUT the data type is a SQL data type, not a COBOL data type.\nA COBOL declaration of 01-CUSTOMER-ROW which lists each column name and data type in the table BUT the data type is a COBOL data type, not a SQL data type.\n","categories":"","description":"This is the CUSTINQ program from the Murach book","excerpt":"This is the CUSTINQ program from the Murach book","ref":"/docs/concepts/orig-code/","tags":"","title":"An example of a normal DB2 ZOS COBOL program"},{"body":"Since DCLGEN isn’t the same on IBM DB2 LUW, create that ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 Add the PERFORM paragraph 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. Then add the 9800-Connect-to DB1 and friends paragraphs * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. ","categories":"","description":"This is the Murach CUSTINQ program with just enough code added to make it work with GnuCOBOL and IBM DB2 LUW.","excerpt":"This is the Murach CUSTINQ program with just enough code added to make …","ref":"/docs/concepts/v1-changes/","tags":"","title":"An overview of specific changes."},{"body":"Brief History Creating GnuCOBOL/DB2 programs on MS Windows. My first attempt at writing GnuCOBOL/DB2 programs was on MS Windows and I followed the instructions found in László Erdős’s contrib.\nIt worked.\nI learned a lot and Thank You to László Erdős for creating that.\n1 - The method it used was a ScreenIO pgm to prompt the user for the parameters and passed them to the program through the Linkage Section. It works but I wanted something “leaner”.\n2 - Then I looked at IBM’s examples and that is where I saw the “ACCEPT” from the command line prompt method. It works, it was “leaner”, but still required interaction with the user.\n3 - Then I thought, use a CALLed program with the parameters embedded in it. CALL it and pass the parameters to the program to then pass those to the DB. GETDBID was created. It works without user interaction.\nCreating GnuCOBOL/DB2 programs on Linux. I needed some help, got it, then posted a link to this site and the repository in the GnuCOBOL discussion area.\nSimon Sobisch, who was very helpful fixing the problems I was having getting started, looked at the code I pushed to the repository. He suggested I use a “.env” file.\nI’ve done that before with Python but had no idea how to do that with COBOL.\n4 - Create a .env file, add code to the run script to export the parameters to environment variables, replace the “CALL ‘GETDBID’” with “ACCEPT FROM ENVIRONMENT”.\nWhich method to use from now on? If the program doesn’t require User Interaction, #4.\nIf the program needs User Interaction, #1 or #2 depending on the situation or maybe something completely different.\nMethod 3 was a good exercise to learn how to CALL programs but I am “retiring” GETDBID.\nWhat about that code in the run script, why that? # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) There are many ways to Set environment variables in Bash.\nOf all the methods listed there, it is a clean, readable method.\nThe .env file only contains 3 parameters of very short length and no spaces.\nSo it doesn’t need to be anything too complicated.\nIt is mostly understandable by people not that familiar with scripting. It only adds the parameters from the .env file. It doesn’t require installing another application (shdotenv). Some methods suggest to add “export” to each line in the .env file and source it.\nTo me, the .env file should be “just parameters, no commands”, but if in the future it is required, there are other versions that would work.\nA unset method is also listed but it is not needed because the script is run in it’s own child shell. A child shell can’t pass variables back up to the parent shell, so the exported variables will disappear as soon as the script finishes and exits the child shell.\n","categories":"","description":"Actually, there are 4 (that I know of, there are probably more).","excerpt":"Actually, there are 4 (that I know of, there are probably more).","ref":"/docs/concepts/supply-parameters/","tags":"","title":"Different methods to pass the connnect parameters?"},{"body":"This is the Murach CUSTINQ program with just enough code added to make it work with GnuCOBOL and IBM DB2 LUW. Breakdown of Changes. IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. ","categories":"","description":"An example of a converted from ZOS/DB2 to GnuCOBOL/DB2 program","excerpt":"An example of a converted from ZOS/DB2 to GnuCOBOL/DB2 program","ref":"/docs/concepts/version1/","tags":"","title":"Version 1"},{"body":"This is the updated CUSTINQ program from the Murach book Code: GETDBID.cbl This is a simple COBOL pgm that can be called by GnuCOBOL programs.\nIt has the userid and password embedded within it.\nCalling this bypasses the ACCEPT of the userid and password.\nCopy the text to tcbl/GETDBID.cbl\nChange the userid and password to the ones on your system.\nNOTE: Just replace the text, make sure the ’ surrounding the text is present.\n********************************************************** * Program name: GETDBID * Original author: David Stagowski * * Description: This is a called module to supply the * the userid and password for the database. * This was written because I got tired of typing them in * everytime I ran the program. * * Maintenence Log * Date Author Maintenance Requirement * --------- ------------ ------------------------------- * 2020-08-18 dastagg * * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. GETDBID. DATA DIVISION. WORKING-STORAGE SECTION. LINKAGE SECTION. 01 DB-User-ID PIC X(10). 01 DB-Passwd-Name PIC X(18). PROCEDURE DIVISION USING DB-User-ID, DB-Passwd-Name. MOVE 'userid' TO DB-User-ID. MOVE 'password' TO DB-Passwd-Name. GOBACK. Change to CUSTINQ Then replace this code:\n9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. With this code:\n9811-Get-Credentials. CALL 'GETDBID' USING DB-User-ID, DB-Passwd-Name. Change to Compile script In order to use this, the Compile script has to be changed to add GETDBID to the compile step.\nPrevious version: #!/bin/bash # Program parms PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi New version #!/bin/bash # Program parms RPGM=CUSTINQ PGM=CUSTINQ LLM=GETDBID # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$RPGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$RPGM ../tcbl/$PGM.cbl ../tcbl/$LLM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi ","categories":"","description":"An example of an enhanced DB2 GnuCOBOL program using GETDBID.","excerpt":"An example of an enhanced DB2 GnuCOBOL program using GETDBID.","ref":"/docs/concepts/version2/","tags":"","title":"Version 2"},{"body":"This is the Murach CUSTINQ program with just enough code added to make it work with GnuCOBOL and IBM DB2 LUW. From the user’s perspective, the result is the same.\nIt is only the structure of the program that is different.\nThe .env file # DB1 Connection parameters db2name=name username=userid password=passwd The compile script\n#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi The run script\n#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM The program.\nIDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. ","categories":"","description":"An example of an enhanced DB2 GnuCOBOL program using ACCEPT FROM ENVIRONMENT","excerpt":"An example of an enhanced DB2 GnuCOBOL program using ACCEPT FROM …","ref":"/docs/concepts/version3/","tags":"","title":"Version 3"},{"body":"From the user’s perspective, the result is the same.\nIt is only the structure of the program that is different. The program.\n********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2020-09-03 dastagg Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 WS-Called-Programs. 12 WS-GetDBId PIC X(8) VALUE SPACES. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. MOVE 'GETDBID' TO WS-GetDBId CALL WS-GetDBId USING DB-User-ID, DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program. ","categories":"","description":"My version of CUSTINQ calling GETDBID","excerpt":"My version of CUSTINQ calling GETDBID","ref":"/docs/concepts/version4/","tags":"","title":"Version 4"},{"body":"From the user’s perspective, the result is the same.\nIt is only the structure of the program that is different. The .env file\nDB1 Connection parameters db2name=name username=userid password=passwd The compile script\n#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi The run script\n#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM # Leaving this here as an example but not required. # Remove the variables in the .env file from the environment # unset $(grep -v '^#' ../.env | sed -E 's/(.*)=.*/\\1/' | xargs) The program.\n********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2023-03-08 dscobol Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program. ","categories":"","description":"My version of CUSTINQ accepting Environment Variable set from a .env file","excerpt":"My version of CUSTINQ accepting Environment Variable set from a .env …","ref":"/docs/concepts/version5/","tags":"","title":"Version 5"},{"body":"After updating the software to IBM DB2 LUW v12.1.1 and GnuCOBOL to 3.2, I cloned and ran:\nibm-gnu-DB2-First-Steps gem-gnu-DB2 to make sure they still work correctly.\nBoth did and I added:\nSome additional code to ibm-gnu-DB2-First-Steps:connectdb to make the tests more explicit. Updated the README.md with additional information. ","categories":"","description":"ibm-gnu-DB2-First-Steps and gem-gnu-DB2 verified.","excerpt":"ibm-gnu-DB2-First-Steps and gem-gnu-DB2 verified.","ref":"/blog/2025/05/27/verified-db2-repositories-work-with-updated-software./","tags":"","title":"Verified DB2 repositories work with updated software."},{"body":"There is a new version of the dscobol.github.io website. See the post under Releases!\nThe Hugo/Docsy combo is working well so far.\nThe old website The new Landing page The new Docs page ","categories":"","description":"New dscobol website using Hugo and Docsy","excerpt":"New dscobol website using Hugo and Docsy","ref":"/blog/2025/05/24/new-version-of-dscobol-website/","tags":"","title":"New version of dscobol website"},{"body":"This is the new version of dscobol.github.io.\nThe new Landing page The new Docs page I decided to use Hugo and Docsy as the static-site generator and theme.\nMajor changes to the website: It now has a “landing page”.\nIt now includes this Blog area.\nDeletions\nRemoved the “Install VM” section. Removed all “if using a VM” comments. Not really necessary. Removed the “Install Basic Dev Env” section. Updates\nUpdated for IBM DB2 LUW v12.1.1. Updated for GnuCOBOL v3.2. Not included in this version but will be added in near future:\nUnder the old Dev Tools section:\nInstall GixSQL Install DBeaver The PostgreSQL section\nThe Zowe section\nThere is also a new Tutorial section. Hopefully, in the future, I will be able to add some useful tutorials.\n","categories":"","description":"A new version of the dscobol.github.io website.","excerpt":"A new version of the dscobol.github.io website.","ref":"/blog/2025/05/24/version-2-of-dscobol-website/","tags":"","title":"Version 2 of dscobol website"},{"body":"This is the old version of dscobol.github.io.\nThe old website It was created with MkDocs and Read the Docs as the static-site generator and theme.\nUsing MkDocs was fine and it worked very well but I decided to try something different.\n","categories":"","description":"Site has been replaced by Hugo/Docsy version.","excerpt":"Site has been replaced by Hugo/Docsy version.","ref":"/blog/2025/05/23/original-dscobol-website-replaced./","tags":"","title":"Original dscobol website replaced."},{"body":"This is the blog section. It has two categories: News and Releases.\nFiles in these directories will be listed in reverse chronological order.\n","categories":"","description":"","excerpt":"This is the blog section. It has two categories: News and Releases. …","ref":"/blog/","tags":"","title":"Blog"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"Welcome to dscobol There are multiple repositories which cover a range of topics and technologies.\nGnuCOBOL - GNU/Linux (Pop!_OS) - COBOL accessing Text files, Indexed data files, DB2, and Postgresql. ZOS - IBM z/OS - COBOL and JCL accessing QSAM, VSAM, DB2, and maybe CICS MVS - TK5 Mainframe emulator - COBOL and KICKS Zowe Framework (A modern interface to interact with z/OS) - COBOL and JCL accessing QSAM, VSAM, and maybe DB2 ","categories":"","description":"","excerpt":"Welcome to dscobol There are multiple repositories which cover a range …","ref":"/docs/","tags":"","title":"Documentation"},{"body":" dscobol Documentation and Blog Site Docs and Tutorials Blog ","categories":"","description":"","excerpt":" dscobol Documentation and Blog Site Docs and Tutorials Blog ","ref":"/","tags":"","title":"dscobol"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]