{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to dscobol There are multiple repositories which cover a range of topics and technologies. GnuCOBOL - Gnu/Linux (Pop!_OS) - COBOL accessing Text files, Indexed data files, DB2, and Postgresql. ZOS - IBM z/OS - COBOL and JCL accessing QSAM, VSAM, DB2, and maybe CICS MVS - TK4- Mainframe emulator - COBOL and KICKS Zowe Framework (A modern interface to interact with z/OS) - COBOL and JCL accessing QSAM, VSAM, and maybe DB2","title":"Home"},{"location":"#welcome-to-dscobol","text":"There are multiple repositories which cover a range of topics and technologies. GnuCOBOL - Gnu/Linux (Pop!_OS) - COBOL accessing Text files, Indexed data files, DB2, and Postgresql. ZOS - IBM z/OS - COBOL and JCL accessing QSAM, VSAM, DB2, and maybe CICS MVS - TK4- Mainframe emulator - COBOL and KICKS Zowe Framework (A modern interface to interact with z/OS) - COBOL and JCL accessing QSAM, VSAM, and maybe DB2","title":"Welcome to dscobol"},{"location":"about/","text":"About dscobol This site and the GitHub repositories were created because I wanted to learn how to write COBOL programs with embedded SQL Statements accessing an IBM DB2 LUW RDBMS using the GnuCOBOL compiler in a Gnu/Linux environment. According to the documentation, IBM DB2 LUW can run on Ubuntu. I like the Pop!_OS UI better then Ubuntu and it is based on Ubuntu so... why not. I created a Virtual Machine with Pop!_OS and off I went. That was a success and I was spending alot of time in the VM and I kind of grew to like Pop!_OS. So, the documentation and guides in this site are ALL for running apps and programs on Pop!_OS . Most of it will also apply to Ubuntu but \"use at your discretion\". What are these repositories, and why are they named the way they are. What is here Within the repositories: COBOL is the primary programming language For programs that run on Gnu/Linux: Bash is the primary scripting language Note: While all these programs have been run using a Pop!_OS VM, GnuCOBOL is not limited to that OS. Using an OS with an Ubuntu base was needed to run IBM DB2 LUW on a Gnu/Linux OS. See the GnuCOBOL site for more information about it's capabilities. For programs that run on ZOS or MVS: JCL is the, well, Job Control Language For Zowe: It is a combination of bash scripts and JCL. Naming Convention The ideas or concepts for the programs may have originated somewhere else(books, tutorials, other websites, etc.) but I try to \"make it my own\" by rewriting it using a different structure and style. First designation dsc - The code was written by dscobol(aka: me) ibm - Code from books, documentation or instruction from IBM. gem - Curtis Garvin, Steve Eckols. DB2 for the COBOL Programmer, Part 1 and 2 . Murach 1991. mca - Michael Coughlan. Beginning COBOL for Programmers Apress 2014. xxx - Code from a website, blog or other source. This will be changed to reflect the source. Second designation gnu - GnuCOBOL zos - IBM Enterprise COBOL mvs - MVS COBOL zow - Zowe Framework Third and further designation A description of the focus of the programs. Examples: dsc-gnu-Indexed dsc - programs by dscobol. gnu - uses the GnuCOBOL compiler Indexed - programs that read and write to Indexed files. gem-gnu-DB2 gem - programs from the \"DB2 for the COBOL Programmer\" book gnu - uses the GnuCOBOL compiler DB2 - connects to the IBM DB2 RDBMS","title":"About"},{"location":"about/#about-dscobol","text":"This site and the GitHub repositories were created because I wanted to learn how to write COBOL programs with embedded SQL Statements accessing an IBM DB2 LUW RDBMS using the GnuCOBOL compiler in a Gnu/Linux environment. According to the documentation, IBM DB2 LUW can run on Ubuntu. I like the Pop!_OS UI better then Ubuntu and it is based on Ubuntu so... why not. I created a Virtual Machine with Pop!_OS and off I went. That was a success and I was spending alot of time in the VM and I kind of grew to like Pop!_OS. So, the documentation and guides in this site are ALL for running apps and programs on Pop!_OS . Most of it will also apply to Ubuntu but \"use at your discretion\".","title":"About dscobol"},{"location":"about/#what-are-these-repositories-and-why-are-they-named-the-way-they-are","text":"","title":"What are these repositories, and why are they named the way they are."},{"location":"about/#what-is-here","text":"Within the repositories: COBOL is the primary programming language For programs that run on Gnu/Linux: Bash is the primary scripting language Note: While all these programs have been run using a Pop!_OS VM, GnuCOBOL is not limited to that OS. Using an OS with an Ubuntu base was needed to run IBM DB2 LUW on a Gnu/Linux OS. See the GnuCOBOL site for more information about it's capabilities. For programs that run on ZOS or MVS: JCL is the, well, Job Control Language For Zowe: It is a combination of bash scripts and JCL.","title":"What is here"},{"location":"about/#naming-convention","text":"The ideas or concepts for the programs may have originated somewhere else(books, tutorials, other websites, etc.) but I try to \"make it my own\" by rewriting it using a different structure and style.","title":"Naming Convention"},{"location":"about/#first-designation","text":"dsc - The code was written by dscobol(aka: me) ibm - Code from books, documentation or instruction from IBM. gem - Curtis Garvin, Steve Eckols. DB2 for the COBOL Programmer, Part 1 and 2 . Murach 1991. mca - Michael Coughlan. Beginning COBOL for Programmers Apress 2014. xxx - Code from a website, blog or other source. This will be changed to reflect the source.","title":"First designation"},{"location":"about/#second-designation","text":"gnu - GnuCOBOL zos - IBM Enterprise COBOL mvs - MVS COBOL zow - Zowe Framework","title":"Second designation"},{"location":"about/#third-and-further-designation","text":"A description of the focus of the programs.","title":"Third and further designation"},{"location":"about/#examples","text":"dsc-gnu-Indexed dsc - programs by dscobol. gnu - uses the GnuCOBOL compiler Indexed - programs that read and write to Indexed files. gem-gnu-DB2 gem - programs from the \"DB2 for the COBOL Programmer\" book gnu - uses the GnuCOBOL compiler DB2 - connects to the IBM DB2 RDBMS","title":"Examples:"},{"location":"change-log/","text":"Change Log for dscobol Website and the GitHub repositories. This will not be an extensive list. Only if there is a substantial change, then it will be documented here. 2023-03-27 dsc-gnu-GixSQL This is an example of a GnuCOBOL program accessing a PostgreSQL DB using GixSQL. 2023-03-24 dsc-ibm-gnu-ECBAP This is a collection of COBOL programs created for the Enterprise COBOL For Business Application Programming class provided by IBM. 2023-03-18 dsc-gnu-db2 Added Inter-Sample directory. This is a series that demonstrates how to create a Table and then load, update and delete rows with that Table. 2023-03-17 dscobol Website As a check, I created a new Virtual Machine, installed IBM DB2 LUW, GnuCOBOL, the Basic Dev Environment, and DBeaver following the instructions. I fixed typos and updated words or phrases to be more accurate. dsc-gnu-db2 I originally used a CALL to GETDBID to pass the DB parameters to the COBOL program which would then use them to connect to the DB2 LUW database. This was replaced by creating a .env file and using an ACCEPT statement instead. I added a Tag to the repository of V1. gem-gnu-db2 I originally used a CALL to GETDBID to pass the DB parameters to the COBOL program which would then use them to connect to the DB2 LUW database. This was replaced by creating a .env file and using an ACCEPT statement instead. I added a Tag to the repository of V1.","title":"Change-Log"},{"location":"change-log/#change-log-for-dscobol-website-and-the-github-repositories","text":"This will not be an extensive list. Only if there is a substantial change, then it will be documented here.","title":"Change Log for dscobol Website and the GitHub repositories."},{"location":"change-log/#2023-03-27","text":"","title":"2023-03-27"},{"location":"change-log/#dsc-gnu-gixsql","text":"This is an example of a GnuCOBOL program accessing a PostgreSQL DB using GixSQL.","title":"dsc-gnu-GixSQL"},{"location":"change-log/#2023-03-24","text":"","title":"2023-03-24"},{"location":"change-log/#dsc-ibm-gnu-ecbap","text":"This is a collection of COBOL programs created for the Enterprise COBOL For Business Application Programming class provided by IBM.","title":"dsc-ibm-gnu-ECBAP"},{"location":"change-log/#2023-03-18","text":"","title":"2023-03-18"},{"location":"change-log/#dsc-gnu-db2","text":"Added Inter-Sample directory. This is a series that demonstrates how to create a Table and then load, update and delete rows with that Table.","title":"dsc-gnu-db2"},{"location":"change-log/#2023-03-17","text":"","title":"2023-03-17"},{"location":"change-log/#dscobol-website","text":"As a check, I created a new Virtual Machine, installed IBM DB2 LUW, GnuCOBOL, the Basic Dev Environment, and DBeaver following the instructions. I fixed typos and updated words or phrases to be more accurate.","title":"dscobol Website"},{"location":"change-log/#dsc-gnu-db2_1","text":"I originally used a CALL to GETDBID to pass the DB parameters to the COBOL program which would then use them to connect to the DB2 LUW database. This was replaced by creating a .env file and using an ACCEPT statement instead. I added a Tag to the repository of V1.","title":"dsc-gnu-db2"},{"location":"change-log/#gem-gnu-db2","text":"I originally used a CALL to GETDBID to pass the DB parameters to the COBOL program which would then use them to connect to the DB2 LUW database. This was replaced by creating a .env file and using an ACCEPT statement instead. I added a Tag to the repository of V1.","title":"gem-gnu-db2"},{"location":"guides/dev-tools/install-basic-dev-env/","text":"Create a Basic Develoment Environment. If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Overview As this is a new installation and you need something to code with, I am recommending the following tools to be productive: This is highly opinionated. If you have your own envionment, create that instead. build-essential : a collection of tools used to build software Git : Source Code Management Vim : for quick edits zsh : a different shell then bash prezto : a zsh framework VS Codium : Not an editor, Not an IDE, Something in the middle Java JDK : Need for IBM Z Open Editor extension Some VS Codium extensions Midnight Commander (aka: mc) : A terminal based file manager An SSH key : to push code to a GitHub or GitLab or Bitbucket repository tree : Optional: a quick way to see the structure of a directory LazyGit : Optional: A terminal based Git UI : This one is really optional. You can use GitLens within VS Codium to do the same, I just like it. Build-Essential sudo apt install build-essential This might be installed already or there might be some components that are missing. Better safe then sorry. Git Actually, Git is already installed on Pop!_OS but if you went the Ubuntu route, you might have to install it. sudo apt install git Vim sudo apt install vim A very dependable editor. Useful for quick edits or as your main editor. Zsh sudo apt install zsh Prezto Visit Github: Prezto and follow the instructions. Just closing/re-opening Terminal doesn't set the shell to zsh. You will probably need to logout of the OS and then log back in to make zsh the default in Terminal. You can use it as it is out of the box but I will suggest one change of two additions: In the /home directory, edit .zpreztorc and add git and syntax-highlighting in the zstyle ':prezto:load' pmodule \\ section: Old version: zstyle ':prezto:load' pmodule \\ 'environment' \\ 'terminal' \\ 'editor' \\ 'history' \\ 'directory' \\ 'spectrum' \\ 'utility' \\ 'completion' \\ 'history-substring-search' \\ 'prompt' New Version: zstyle ':prezto:load' pmodule \\ 'environment' \\ 'terminal' \\ 'editor' \\ 'history' \\ 'directory' \\ 'spectrum' \\ 'utility' \\ 'completion' \\ 'git' \\ 'syntax-highlighting' \\ 'history-substring-search' \\ 'prompt' Save it, close Terminal then open Terminal. Add db2profile to .zshrc Similar to adding this to .bashrc: Add the following 4 lines to the bottom of the .zshrc file which is found in the home directory. # The following three lines have been added by UDB DB2. if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profile fi This will also export some very useful environment variables. You will need to exit and re-open Terminal for them to be activated. VS Codium Because... why not. Go to VS Codium website . Follow the instructions for \"Install on Debian/Ubuntu(deb package)\": Add GPG key Add the repository Update and Install codium Java JDK sudo apt install default-jdk VS Codium Extensions Open VSCodium, Open the Extensions Browser and install: IBM Z Open Editor (will also install Zowe Explorer) GitLens You could also install Code4Z instead of IBM Z Open Editor BUT don't have both installed at the same time. Close/Open VSCodium for the extensions to work properly. Midnight Commander (aka: mc) sudo apt install mc This is a nice terminal based file manager that I use to transfer files to/from the host/vm and move stuff around in general. SSH-Key For instructions: Look at GitHub - Connect with SSH . Tree - Optional sudo apt install tree LazyGit - Optional Follow the instructions on the LazyGit - Github website.","title":"Install Basic Dev Env"},{"location":"guides/dev-tools/install-basic-dev-env/#create-a-basic-develoment-environment","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Create a Basic Develoment Environment."},{"location":"guides/dev-tools/install-basic-dev-env/#overview","text":"As this is a new installation and you need something to code with, I am recommending the following tools to be productive: This is highly opinionated. If you have your own envionment, create that instead. build-essential : a collection of tools used to build software Git : Source Code Management Vim : for quick edits zsh : a different shell then bash prezto : a zsh framework VS Codium : Not an editor, Not an IDE, Something in the middle Java JDK : Need for IBM Z Open Editor extension Some VS Codium extensions Midnight Commander (aka: mc) : A terminal based file manager An SSH key : to push code to a GitHub or GitLab or Bitbucket repository tree : Optional: a quick way to see the structure of a directory LazyGit : Optional: A terminal based Git UI : This one is really optional. You can use GitLens within VS Codium to do the same, I just like it.","title":"Overview"},{"location":"guides/dev-tools/install-basic-dev-env/#build-essential","text":"sudo apt install build-essential This might be installed already or there might be some components that are missing. Better safe then sorry.","title":"Build-Essential"},{"location":"guides/dev-tools/install-basic-dev-env/#git","text":"Actually, Git is already installed on Pop!_OS but if you went the Ubuntu route, you might have to install it. sudo apt install git","title":"Git"},{"location":"guides/dev-tools/install-basic-dev-env/#vim","text":"sudo apt install vim A very dependable editor. Useful for quick edits or as your main editor.","title":"Vim"},{"location":"guides/dev-tools/install-basic-dev-env/#zsh","text":"sudo apt install zsh","title":"Zsh"},{"location":"guides/dev-tools/install-basic-dev-env/#prezto","text":"Visit Github: Prezto and follow the instructions. Just closing/re-opening Terminal doesn't set the shell to zsh. You will probably need to logout of the OS and then log back in to make zsh the default in Terminal. You can use it as it is out of the box but I will suggest one change of two additions: In the /home directory, edit .zpreztorc and add git and syntax-highlighting in the zstyle ':prezto:load' pmodule \\ section: Old version: zstyle ':prezto:load' pmodule \\ 'environment' \\ 'terminal' \\ 'editor' \\ 'history' \\ 'directory' \\ 'spectrum' \\ 'utility' \\ 'completion' \\ 'history-substring-search' \\ 'prompt' New Version: zstyle ':prezto:load' pmodule \\ 'environment' \\ 'terminal' \\ 'editor' \\ 'history' \\ 'directory' \\ 'spectrum' \\ 'utility' \\ 'completion' \\ 'git' \\ 'syntax-highlighting' \\ 'history-substring-search' \\ 'prompt' Save it, close Terminal then open Terminal.","title":"Prezto"},{"location":"guides/dev-tools/install-basic-dev-env/#add-db2profile-to-zshrc","text":"Similar to adding this to .bashrc: Add the following 4 lines to the bottom of the .zshrc file which is found in the home directory. # The following three lines have been added by UDB DB2. if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profile fi This will also export some very useful environment variables. You will need to exit and re-open Terminal for them to be activated.","title":"Add db2profile to .zshrc"},{"location":"guides/dev-tools/install-basic-dev-env/#vs-codium","text":"Because... why not. Go to VS Codium website . Follow the instructions for \"Install on Debian/Ubuntu(deb package)\": Add GPG key Add the repository Update and Install codium","title":"VS Codium"},{"location":"guides/dev-tools/install-basic-dev-env/#java-jdk","text":"sudo apt install default-jdk","title":"Java JDK"},{"location":"guides/dev-tools/install-basic-dev-env/#vs-codium-extensions","text":"Open VSCodium, Open the Extensions Browser and install: IBM Z Open Editor (will also install Zowe Explorer) GitLens You could also install Code4Z instead of IBM Z Open Editor BUT don't have both installed at the same time. Close/Open VSCodium for the extensions to work properly.","title":"VS Codium Extensions"},{"location":"guides/dev-tools/install-basic-dev-env/#midnight-commander-aka-mc","text":"sudo apt install mc This is a nice terminal based file manager that I use to transfer files to/from the host/vm and move stuff around in general.","title":"Midnight Commander (aka: mc)"},{"location":"guides/dev-tools/install-basic-dev-env/#ssh-key","text":"For instructions: Look at GitHub - Connect with SSH .","title":"SSH-Key"},{"location":"guides/dev-tools/install-basic-dev-env/#tree-optional","text":"sudo apt install tree","title":"Tree - Optional"},{"location":"guides/dev-tools/install-basic-dev-env/#lazygit-optional","text":"Follow the instructions on the LazyGit - Github website.","title":"LazyGit - Optional"},{"location":"guides/dev-tools/install-dbeaver/","text":"Install DBeaver If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. There are a couple of ways to install it. I went with Linux Shout 's version: #1st Method Using an APT repository Connect to IBM DB2 LUW This part was a little tricky. Open the app and click on \"New Database Connection\". Select DB2 for LUW Here's the problem: All the tutorials, posts, and videos say: Host=localhost and Port=50000 or Port=50001 But this doesn't work. There are 2 issues with this: Wrong Host Wrong Port Cat the /etc/hosts file. In this VM, it looks like: ~ \u276f\u276f\u276f cat /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 pop-os.localdomain pop-os ~ \u276f\u276f\u276f And, in the DB2 install log, it says: Port 25000. So, in this VM, the correct parameters are: Host: pop-os Port: 25000 Fill in the other parameters: Database (probably: sample) Username (probably: db2inst1) Password (whatever it is) and press the \"Test Connection\" button. If this is the first time you are making a connection, you will have to download the drivers. After that, you should see a dialog box pop up stating: Connected .","title":"Install DBeaver"},{"location":"guides/dev-tools/install-dbeaver/#install-dbeaver","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. There are a couple of ways to install it. I went with Linux Shout 's version: #1st Method Using an APT repository","title":"Install DBeaver"},{"location":"guides/dev-tools/install-dbeaver/#connect-to-ibm-db2-luw","text":"This part was a little tricky. Open the app and click on \"New Database Connection\". Select DB2 for LUW Here's the problem: All the tutorials, posts, and videos say: Host=localhost and Port=50000 or Port=50001 But this doesn't work. There are 2 issues with this: Wrong Host Wrong Port Cat the /etc/hosts file. In this VM, it looks like: ~ \u276f\u276f\u276f cat /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 pop-os.localdomain pop-os ~ \u276f\u276f\u276f And, in the DB2 install log, it says: Port 25000. So, in this VM, the correct parameters are: Host: pop-os Port: 25000 Fill in the other parameters: Database (probably: sample) Username (probably: db2inst1) Password (whatever it is) and press the \"Test Connection\" button. If this is the first time you are making a connection, you will have to download the drivers. After that, you should see a dialog box pop up stating: Connected .","title":"Connect to IBM DB2 LUW"},{"location":"guides/dev-tools/install-gixsql/","text":"Install GixSQL READ the README on GitHub for lots of information. It's what I used to create these instructions. Get GixSQL Download the source code from GixSQL As of March 26, 2023, the current version is v1.0.20a. For that version, download: gixsql-1.0.20a.tar.gz. If you haven't made any changes, it will be downloaded to the Downloads directory. Extract the downloaded file Open Files and go to the Downloads folder. Double click on the gixsql-1.0.20a.tar.gz file. This will open Archive Manager. You will see \"gixsql-1.0.20a\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files. Install additional software The instructions include this line: sudo apt install libmariadb-dev libpq-dev unixodbc-dev flex But, at this time, I don't care about Mariadb(MySQL) or odbc. See NOTE below if you do. Open Terminal to install the following: sudo apt install libpq-dev flex sudo apt install libspdlog-dev libfmt-dev sudo apt install bison Configure, Make and Install Run: cd builds/gixsql-1.0.20a This will take you into the gixsql-1.0.20a directory. Run: ./configure --prefix=/opt/gixsql --disable-mysql --disable-odbc --enable-pgsql A whole bunch of messages will print on the screen If there are no errors, Run: make If there are no errors, Run: sudo make install Then Run: sudo ldconfig NOTE: Install the other DBs If you do want to use MySQL(Maria) and/or odbc, replace the apt install: sudo apt install libpq-dev flex With sudo apt install libmariadb-dev libpq-dev unixodbc-dev flex And the ./configure: ./configure --prefix=/opt/gixsql --disable-mysql --disable-odbc --enable-pgsql With ./configure --prefix=/opt/gixsql","title":"Install GixSQL"},{"location":"guides/dev-tools/install-gixsql/#install-gixsql","text":"READ the README on GitHub for lots of information. It's what I used to create these instructions.","title":"Install GixSQL"},{"location":"guides/dev-tools/install-gixsql/#get-gixsql","text":"Download the source code from GixSQL As of March 26, 2023, the current version is v1.0.20a. For that version, download: gixsql-1.0.20a.tar.gz. If you haven't made any changes, it will be downloaded to the Downloads directory.","title":"Get GixSQL"},{"location":"guides/dev-tools/install-gixsql/#extract-the-downloaded-file","text":"Open Files and go to the Downloads folder. Double click on the gixsql-1.0.20a.tar.gz file. This will open Archive Manager. You will see \"gixsql-1.0.20a\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files.","title":"Extract the downloaded file"},{"location":"guides/dev-tools/install-gixsql/#install-additional-software","text":"The instructions include this line: sudo apt install libmariadb-dev libpq-dev unixodbc-dev flex But, at this time, I don't care about Mariadb(MySQL) or odbc. See NOTE below if you do. Open Terminal to install the following: sudo apt install libpq-dev flex sudo apt install libspdlog-dev libfmt-dev sudo apt install bison","title":"Install additional software"},{"location":"guides/dev-tools/install-gixsql/#configure-make-and-install","text":"Run: cd builds/gixsql-1.0.20a This will take you into the gixsql-1.0.20a directory. Run: ./configure --prefix=/opt/gixsql --disable-mysql --disable-odbc --enable-pgsql A whole bunch of messages will print on the screen If there are no errors, Run: make If there are no errors, Run: sudo make install Then Run: sudo ldconfig NOTE: Install the other DBs If you do want to use MySQL(Maria) and/or odbc, replace the apt install: sudo apt install libpq-dev flex With sudo apt install libmariadb-dev libpq-dev unixodbc-dev flex And the ./configure: ./configure --prefix=/opt/gixsql --disable-mysql --disable-odbc --enable-pgsql With ./configure --prefix=/opt/gixsql","title":"Configure, Make and Install"},{"location":"guides/dev-tools/install-gnucobol/","text":"Install GnuCOBOL If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Install Build-Essential first In Terminal, Run: sudo apt install build-essential This might be installed already or there might be some components that are missing. Better safe then sorry. Get GnuCOBOL Download the source code from GnuCOBOL As of March 1, 2023, the current version is 3.1.2. For that version, download: gnucobol-3.1.2.tar.xz. If you haven't made any changes, it will be downloaded to the Downloads directory. Extract the downloaded file Open Files and go to the Downloads folder. Double click on the gnucobol-3.1.2.tar.xz file. This will open Archive Manager. You will see \"gnucobol-3.1.2\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files. Install additional software Open Terminal to install the following: sudo apt install libgmp-dev sudo apt install libdb5.3-dev sudo apt install libncurses-dev sudo apt install libxml2-dev sudo apt install libcjson-dev Configure, Make and Install Run: cd builds/gnucobol-3.1.2 This will take you into the gnucobol-3.1.2 directory. Run: ./configure A whole bunch of messages will print on the screen At the end, there should be some messages that look like: extended screen I/O : ncursesw variable file format : 0 sequential file handler : built-in indexed file handler : BDB mathematical library : GMP XML library : libxml2 JSON library : json-c If there are no errors, Run: make More messages will display, if there are no errors, Run: make check A suite of tests will run, at the end, you should see the results: 1082 tests behaved as expected. 4 tests were skipped Run: sudo make install Then Run: sudo ldconfig As a quick test, Run: cobc You should get an error message: cobc: error: no input files For a better test of the install: Create a new directory Create a simple COBOL program Run it. 1: Create a new directory In Terminal, Run: cd mkdir -p ~/dev/cobol/test-cobol cd ~/dev/cobol/test-cobol touch hello.cbl 2: Create a simple COBOL program Open Files, go to the dev/cobol/test-cobol folder. Double-click on hello.cbl. This will open it in Text Editor. Copy the following code and paste it into hello.cbl: IDENTIFICATION DIVISION. PROGRAM-ID. SmallestProgram. DATA DIVISION. FILE SECTION. WORKING-STORAGE SECTION. PROCEDURE DIVISION. MAIN-PROCEDURE. DISPLAY \"Hello world\" STOP RUN. END PROGRAM SmallestProgram. and save it. Go to Terminal, Run: pwd To make sure you are in the ~/dev/cobol/test-cobol directory. Run: cobc -x hello.cbl If it complies correctly(no messages), Run: ./hello It should return: Hello world If this works, delete the test-cobol directory (or not, your choice).","title":"Install GnuCOBOL"},{"location":"guides/dev-tools/install-gnucobol/#install-gnucobol","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Install GnuCOBOL"},{"location":"guides/dev-tools/install-gnucobol/#install-build-essential-first","text":"In Terminal, Run: sudo apt install build-essential This might be installed already or there might be some components that are missing. Better safe then sorry.","title":"Install Build-Essential first"},{"location":"guides/dev-tools/install-gnucobol/#get-gnucobol","text":"Download the source code from GnuCOBOL As of March 1, 2023, the current version is 3.1.2. For that version, download: gnucobol-3.1.2.tar.xz. If you haven't made any changes, it will be downloaded to the Downloads directory.","title":"Get GnuCOBOL"},{"location":"guides/dev-tools/install-gnucobol/#extract-the-downloaded-file","text":"Open Files and go to the Downloads folder. Double click on the gnucobol-3.1.2.tar.xz file. This will open Archive Manager. You will see \"gnucobol-3.1.2\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files.","title":"Extract the downloaded file"},{"location":"guides/dev-tools/install-gnucobol/#install-additional-software","text":"Open Terminal to install the following: sudo apt install libgmp-dev sudo apt install libdb5.3-dev sudo apt install libncurses-dev sudo apt install libxml2-dev sudo apt install libcjson-dev","title":"Install additional software"},{"location":"guides/dev-tools/install-gnucobol/#configure-make-and-install","text":"Run: cd builds/gnucobol-3.1.2 This will take you into the gnucobol-3.1.2 directory. Run: ./configure A whole bunch of messages will print on the screen At the end, there should be some messages that look like: extended screen I/O : ncursesw variable file format : 0 sequential file handler : built-in indexed file handler : BDB mathematical library : GMP XML library : libxml2 JSON library : json-c If there are no errors, Run: make More messages will display, if there are no errors, Run: make check A suite of tests will run, at the end, you should see the results: 1082 tests behaved as expected. 4 tests were skipped Run: sudo make install Then Run: sudo ldconfig As a quick test, Run: cobc You should get an error message: cobc: error: no input files For a better test of the install: Create a new directory Create a simple COBOL program Run it.","title":"Configure, Make and Install"},{"location":"guides/dev-tools/install-gnucobol/#1-create-a-new-directory","text":"In Terminal, Run: cd mkdir -p ~/dev/cobol/test-cobol cd ~/dev/cobol/test-cobol touch hello.cbl","title":"1: Create a new directory"},{"location":"guides/dev-tools/install-gnucobol/#2-create-a-simple-cobol-program","text":"Open Files, go to the dev/cobol/test-cobol folder. Double-click on hello.cbl. This will open it in Text Editor. Copy the following code and paste it into hello.cbl: IDENTIFICATION DIVISION. PROGRAM-ID. SmallestProgram. DATA DIVISION. FILE SECTION. WORKING-STORAGE SECTION. PROCEDURE DIVISION. MAIN-PROCEDURE. DISPLAY \"Hello world\" STOP RUN. END PROGRAM SmallestProgram. and save it. Go to Terminal, Run: pwd To make sure you are in the ~/dev/cobol/test-cobol directory. Run: cobc -x hello.cbl If it complies correctly(no messages), Run: ./hello It should return: Hello world If this works, delete the test-cobol directory (or not, your choice).","title":"2: Create a simple COBOL program"},{"location":"guides/dev-tools/overview/","text":"Overview If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Install GnuCOBOL Install GnuCOBOL Install a Basic Development Environment Install Dev Env Install DBeaver Install DBeaver","title":"Overview"},{"location":"guides/dev-tools/overview/#overview","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Overview"},{"location":"guides/dev-tools/overview/#install-gnucobol","text":"Install GnuCOBOL","title":"Install GnuCOBOL"},{"location":"guides/dev-tools/overview/#install-a-basic-development-environment","text":"Install Dev Env","title":"Install a Basic Development Environment"},{"location":"guides/dev-tools/overview/#install-dbeaver","text":"Install DBeaver","title":"Install DBeaver"},{"location":"guides/gnu-vs-zos-cobol/overview-gnu-vs-zos-cobol/","text":"Overview GnuCOBOL vs ZOS COBOL This is broken up into two areas: Batch or \"Normal\" COBOL DB2 COBOL","title":"Overview of the differences"},{"location":"guides/gnu-vs-zos-cobol/overview-gnu-vs-zos-cobol/#overview-gnucobol-vs-zos-cobol","text":"This is broken up into two areas: Batch or \"Normal\" COBOL DB2 COBOL","title":"Overview GnuCOBOL vs ZOS COBOL"},{"location":"guides/gnu-vs-zos-cobol/batch/overview-batch-zos-vs-gnucobol/","text":"Overview - Batch processing: zOS COBOL vs GnuCOBOL I can't speak about the efficiency or the scalablity or \"benchmarking performance\" between zOS COBOL and GnuCOBOL. I just don't know. From an application programmer's point of view though, these are the differences that I know of: INPUT-OUTPUT SECTION : FILE-CONTROL This is the one place where you probably need to make changes. This is a snippet I copied from one of the programs I wrote a while back: INPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO \"../data/psap.dat.txt\" ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status. This would compile and run using GnuCOBOL. If I copied this program to a zOS Mainframe, I would uncomment the first ASSIGN and ORGANIZATION lines and comment the next two and that would run on the Mainframe. But, the ASSIGN statement is \"hardcoded\". If the file needed to be changed, the program would have to be updated then re-compiled. Here is a \"better, more recent version\": INPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO QIPSAPFILE ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status. ASSIGN statement From the GnuCOBOL documentation: For example, given ASSIGN TO \"DATAFILE\", the actual file name will be 1. the value of environment variable 'DD_DATAFILE' or 2. the value of environment variable 'dd_DATAFILE' or 3. the value of environment variable 'DATAFILE' or 4. the literal \"DATAFILE\" So, under GNU/Linux, bash shell export DD_QIPSAPFILE='../data/psap.dat.txt' ./myprog However, you cannot name it the same as the SELECT variable as that will be an error. On the Mainframe, you can \"get around this\" by prefixing the ASSIGN variable with \"DA-S-\" (or other versions of this) and the compiler will parse just the last part and use that for the JCL. ORGANIZATION statement The other change that must be made for sequential files using GnuCOBOL is the addition of the keyword \"LINE\" Mainframe: ORGANIZATION IS SEQUENTIAL GnuCOBOL ORGANIZATION IS LINE SEQUENTIAL This is because on the Mainframe, most files are a fixed length so there isn't a \"LF\" or \"CRLF\" at the end of each line. For sequential input files, the \"LINE\" keyword tells GnuCOBOL to examine the record, look for the line ending and strip that off before trying to process the record. For sequential output files, The \"LINE\" keyword tells GnuCOBOL to append a line feed character at the end of each record before it writes it out.","title":"Overview"},{"location":"guides/gnu-vs-zos-cobol/batch/overview-batch-zos-vs-gnucobol/#overview-batch-processing-zos-cobol-vs-gnucobol","text":"I can't speak about the efficiency or the scalablity or \"benchmarking performance\" between zOS COBOL and GnuCOBOL. I just don't know. From an application programmer's point of view though, these are the differences that I know of:","title":"Overview - Batch processing: zOS COBOL vs GnuCOBOL"},{"location":"guides/gnu-vs-zos-cobol/batch/overview-batch-zos-vs-gnucobol/#input-output-section-file-control","text":"This is the one place where you probably need to make changes. This is a snippet I copied from one of the programs I wrote a while back: INPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO \"../data/psap.dat.txt\" ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status. This would compile and run using GnuCOBOL. If I copied this program to a zOS Mainframe, I would uncomment the first ASSIGN and ORGANIZATION lines and comment the next two and that would run on the Mainframe. But, the ASSIGN statement is \"hardcoded\". If the file needed to be changed, the program would have to be updated then re-compiled. Here is a \"better, more recent version\": INPUT-OUTPUT SECTION. FILE-CONTROL. SELECT PSAPFile * ASSIGN TO PSAPFILE * ORGANIZATION IS SEQUENTIAL ASSIGN TO QIPSAPFILE ORGANIZATION IS LINE SEQUENTIAL FILE STATUS IS WS-PSAPFile-Status.","title":"INPUT-OUTPUT SECTION : FILE-CONTROL"},{"location":"guides/gnu-vs-zos-cobol/batch/overview-batch-zos-vs-gnucobol/#assign-statement","text":"From the GnuCOBOL documentation: For example, given ASSIGN TO \"DATAFILE\", the actual file name will be 1. the value of environment variable 'DD_DATAFILE' or 2. the value of environment variable 'dd_DATAFILE' or 3. the value of environment variable 'DATAFILE' or 4. the literal \"DATAFILE\" So, under GNU/Linux, bash shell export DD_QIPSAPFILE='../data/psap.dat.txt' ./myprog However, you cannot name it the same as the SELECT variable as that will be an error. On the Mainframe, you can \"get around this\" by prefixing the ASSIGN variable with \"DA-S-\" (or other versions of this) and the compiler will parse just the last part and use that for the JCL.","title":"ASSIGN statement"},{"location":"guides/gnu-vs-zos-cobol/batch/overview-batch-zos-vs-gnucobol/#organization-statement","text":"The other change that must be made for sequential files using GnuCOBOL is the addition of the keyword \"LINE\" Mainframe: ORGANIZATION IS SEQUENTIAL GnuCOBOL ORGANIZATION IS LINE SEQUENTIAL This is because on the Mainframe, most files are a fixed length so there isn't a \"LF\" or \"CRLF\" at the end of each line. For sequential input files, the \"LINE\" keyword tells GnuCOBOL to examine the record, look for the line ending and strip that off before trying to process the record. For sequential output files, The \"LINE\" keyword tells GnuCOBOL to append a line feed character at the end of each record before it writes it out.","title":"ORGANIZATION statement"},{"location":"guides/gnu-vs-zos-cobol/db2/converted-to-gnu-db2-cobol/","text":"An example of a converted from ZOS/DB2 to GnuCOBOL/DB2 program This is the Murach CUSTINQ program with just enough code added to make it work with GnuCOBOL and IBM DB2 LUW. Breakdown of Changes program. IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"An example of a converted from ZOS/DB2 to GnuCOBOL/DB2 program"},{"location":"guides/gnu-vs-zos-cobol/db2/converted-to-gnu-db2-cobol/#an-example-of-a-converted-from-zosdb2-to-gnucoboldb2-program","text":"","title":"An example of a converted from ZOS/DB2 to GnuCOBOL/DB2 program"},{"location":"guides/gnu-vs-zos-cobol/db2/converted-to-gnu-db2-cobol/#this-is-the-murach-custinq-program-with-just-enough-code-added-to-make-it-work-with-gnucobol-and-ibm-db2-luw","text":"Breakdown of Changes program. IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"This is the Murach CUSTINQ program with just enough code added to make it work with GnuCOBOL and IBM DB2 LUW."},{"location":"guides/gnu-vs-zos-cobol/db2/different-methods-to-connect/","text":"Why 3 different methods to pass the connnect parameters? Actually, there are 4 (that I know of, there are probably more). Brief History My first attempt at writing GnuCOBOL/DB2 programs was on Windows and I followed the instructions found in L\u00e1szl\u00f3 Erd\u0151s's contrib . It worked. I learned a lot and Thank You to L\u00e1szl\u00f3 Erd\u0151s for creating that. 1 - The method it used was a ScreenIO pgm to prompt the user for the parameters and passed them to the program through the Linkage Section. It works but I wanted something \"leaner\". 2 - Then I looked at IBM's examples and that is where I saw the \"ACCEPT\" from the command line prompt method. It works, it was \"leaner\", but still required interaction with the user. 3 - Then I thought, use a CALLed program with the parameters embedded in it. CALL it and pass the parameters to the program to then pass those to the DB. GETDBID was created. It works without user interaction. Then, per the \"About\" of this site and repository, I want to create GnuCOBOL/DB2 programs on Linux. I needed some help, got it, then posted a link to this site and the repository in the GnuCOBOL discussion area. Simon Sobisch, who was very helpful fixing the problems I was having getting started, looked at the code I pushed to the repository. One repeated \"suggestion\" (more like: Umm... I think you can do better.): Use a .env file. I've done that before with Python but had no idea how to do that with COBOL. But, he also dropped some hints. 4 - Create a .env file, add code to the run script to export the parameters to environment variables, replace the \"CALL 'GETDBID'\" with \"ACCEPT FROM ENVIRONMENT\". Which method to use from now on? If the program doesn't require User Interaction, #4. If the program needs User Interaction, #1 or #2 depending on the situation or maybe something completely different. Method 3 was a good exercise to learn how to CALL programs but I am \"retiring\" GETDBID. What about that code in the run script, why that? There are many ways to Set environment variables in Bash . Of all the methods listed there, it is a clean, readable method. The .env file only contains 3 parameters of very short length and no spaces. So it doesn't need to be anything too complicated. It is mostly understandable by people not that familiar with scripting. It only adds the parameters from the .env file. It doesn't require installing another application (shdotenv). Some methods suggest to add \"export\" to each line in the .env file and source it. To me, the .env file should be \"just parameters, no commands\", but if in the future it is required, there are other versions that would work. A unset method is also listed but it is not needed. The script is run in it's own child shell. A child shell can't export variables back up to the parent shell, so the exported variables will disappear as soon as the script finishes and exits the child shell.","title":"Why 3 different methods to pass the connnect parameters?"},{"location":"guides/gnu-vs-zos-cobol/db2/different-methods-to-connect/#why-3-different-methods-to-pass-the-connnect-parameters","text":"Actually, there are 4 (that I know of, there are probably more).","title":"Why 3 different methods to pass the connnect parameters?"},{"location":"guides/gnu-vs-zos-cobol/db2/different-methods-to-connect/#brief-history","text":"My first attempt at writing GnuCOBOL/DB2 programs was on Windows and I followed the instructions found in L\u00e1szl\u00f3 Erd\u0151s's contrib . It worked. I learned a lot and Thank You to L\u00e1szl\u00f3 Erd\u0151s for creating that. 1 - The method it used was a ScreenIO pgm to prompt the user for the parameters and passed them to the program through the Linkage Section. It works but I wanted something \"leaner\". 2 - Then I looked at IBM's examples and that is where I saw the \"ACCEPT\" from the command line prompt method. It works, it was \"leaner\", but still required interaction with the user. 3 - Then I thought, use a CALLed program with the parameters embedded in it. CALL it and pass the parameters to the program to then pass those to the DB. GETDBID was created. It works without user interaction. Then, per the \"About\" of this site and repository, I want to create GnuCOBOL/DB2 programs on Linux. I needed some help, got it, then posted a link to this site and the repository in the GnuCOBOL discussion area. Simon Sobisch, who was very helpful fixing the problems I was having getting started, looked at the code I pushed to the repository. One repeated \"suggestion\" (more like: Umm... I think you can do better.): Use a .env file. I've done that before with Python but had no idea how to do that with COBOL. But, he also dropped some hints. 4 - Create a .env file, add code to the run script to export the parameters to environment variables, replace the \"CALL 'GETDBID'\" with \"ACCEPT FROM ENVIRONMENT\".","title":"Brief History"},{"location":"guides/gnu-vs-zos-cobol/db2/different-methods-to-connect/#which-method-to-use-from-now-on","text":"If the program doesn't require User Interaction, #4. If the program needs User Interaction, #1 or #2 depending on the situation or maybe something completely different. Method 3 was a good exercise to learn how to CALL programs but I am \"retiring\" GETDBID.","title":"Which method to use from now on?"},{"location":"guides/gnu-vs-zos-cobol/db2/different-methods-to-connect/#what-about-that-code-in-the-run-script-why-that","text":"There are many ways to Set environment variables in Bash . Of all the methods listed there, it is a clean, readable method. The .env file only contains 3 parameters of very short length and no spaces. So it doesn't need to be anything too complicated. It is mostly understandable by people not that familiar with scripting. It only adds the parameters from the .env file. It doesn't require installing another application (shdotenv). Some methods suggest to add \"export\" to each line in the .env file and source it. To me, the .env file should be \"just parameters, no commands\", but if in the future it is required, there are other versions that would work. A unset method is also listed but it is not needed. The script is run in it's own child shell. A child shell can't export variables back up to the parent shell, so the exported variables will disappear as soon as the script finishes and exits the child shell.","title":"What about that code in the run script, why that?"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/","text":"An example of an enhanced DB2 GnuCOBOL program using GETDBID. Code: GETDBID.cbl This is a simple COBOL pgm that can be called by GnuCOBOL programs. It has the userid and password embedded within it. Calling this bypasses the ACCEPT of the userid and password. Copy the text to tcbl/GETDBID.cbl Change the userid and password to the ones on your system. NOTE: Just replace the text, make sure the ' surrounding the text is present. ********************************************************** * Program name: GETDBID * Original author: David Stagowski * * Description: This is a called module to supply the * the userid and password for the database. * This was written because I got tired of typing them in * everytime I ran the program. * * Maintenence Log * Date Author Maintenance Requirement * --------- ------------ ------------------------------- * 2020-08-18 dastagg * * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. GETDBID. DATA DIVISION. WORKING-STORAGE SECTION. LINKAGE SECTION. 01 DB-User-ID PIC X(10). 01 DB-Passwd-Name PIC X(18). PROCEDURE DIVISION USING DB-User-ID, DB-Passwd-Name. MOVE 'userid' TO DB-User-ID. MOVE 'password' TO DB-Passwd-Name. GOBACK. Change to CUSTINQ Then replace this code: 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. With this code: 9811-Get-Credentials. CALL 'GETDBID' USING DB-User-ID, DB-Passwd-Name. Change to Compile script In order to use this, the Compile script has to be changed to add GETDBID to the compile step. Previous version: #!/bin/bash # Program parms PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi New version #!/bin/bash # Program parms RPGM=CUSTINQ PGM=CUSTINQ LLM=GETDBID # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$RPGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$RPGM ../tcbl/$PGM.cbl ../tcbl/$LLM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi","title":"An example of an enhanced DB2 GnuCOBOL program using GETDBID."},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#an-example-of-an-enhanced-db2-gnucobol-program-using-getdbid","text":"","title":"An example of an enhanced DB2 GnuCOBOL program using GETDBID."},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#code-getdbidcbl","text":"This is a simple COBOL pgm that can be called by GnuCOBOL programs. It has the userid and password embedded within it. Calling this bypasses the ACCEPT of the userid and password. Copy the text to tcbl/GETDBID.cbl Change the userid and password to the ones on your system. NOTE: Just replace the text, make sure the ' surrounding the text is present. ********************************************************** * Program name: GETDBID * Original author: David Stagowski * * Description: This is a called module to supply the * the userid and password for the database. * This was written because I got tired of typing them in * everytime I ran the program. * * Maintenence Log * Date Author Maintenance Requirement * --------- ------------ ------------------------------- * 2020-08-18 dastagg * * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. GETDBID. DATA DIVISION. WORKING-STORAGE SECTION. LINKAGE SECTION. 01 DB-User-ID PIC X(10). 01 DB-Passwd-Name PIC X(18). PROCEDURE DIVISION USING DB-User-ID, DB-Passwd-Name. MOVE 'userid' TO DB-User-ID. MOVE 'password' TO DB-Passwd-Name. GOBACK.","title":"Code: GETDBID.cbl"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#change-to-custinq","text":"Then replace this code: 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. With this code: 9811-Get-Credentials. CALL 'GETDBID' USING DB-User-ID, DB-Passwd-Name.","title":"Change to CUSTINQ"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#change-to-compile-script","text":"In order to use this, the Compile script has to be changed to add GETDBID to the compile step.","title":"Change to Compile script"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#previous-version","text":"#!/bin/bash # Program parms PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi","title":"Previous version:"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v2-db2-gnu-cobol/#new-version","text":"#!/bin/bash # Program parms RPGM=CUSTINQ PGM=CUSTINQ LLM=GETDBID # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Clean up rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$RPGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$RPGM ../tcbl/$PGM.cbl ../tcbl/$LLM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"Complier Return code was ZERO.\" else echo \"Complier Return code not ZERO.\" fi","title":"New version"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/","text":"An example of an enhanced DB2 GnuCOBOL program using ACCEPT FROM ENVIRONMENT From the user's perspective, the result is the same. It is only the structure of the program that is different. The .env file # DB1 Connection parameters db2name=names username=userid password=passwd The compile script #!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi The run script #!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM # Remove the variables in the .env file from the environment unset $(grep -v '^#' ../.env | sed -E 's/(.*)=.*/\\1/' | xargs) The program. IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"An example of an enhanced DB2 GnuCOBOL program using ACCEPT FROM ENVIRONMENT"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/#an-example-of-an-enhanced-db2-gnucobol-program-using-accept-from-environment","text":"From the user's perspective, the result is the same. It is only the structure of the program that is different.","title":"An example of an enhanced DB2 GnuCOBOL program using ACCEPT FROM ENVIRONMENT"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/#the-env-file","text":"# DB1 Connection parameters db2name=names username=userid password=passwd","title":"The .env file"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/#the-compile-script","text":"#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi","title":"The compile script"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/#the-run-script","text":"#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM # Remove the variables in the .env file from the environment unset $(grep -v '^#' ../.env | sed -E 's/(.*)=.*/\\1/' | xargs)","title":"The run script"},{"location":"guides/gnu-vs-zos-cobol/db2/enhanced-v3-db2-gnu-cobol/#the-program","text":"IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. EXEC SQL INCLUDE SQLCA END-EXEC. * ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM CUSTOMERS WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"The program."},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/","text":"My version of CUSTINQ accepting Environment Variable set from a .env file From the user's perspective, the result is the same. It is only the structure of the program that is different. The .env file # DB1 Connection parameters db2name=names username=userid password=passwd The compile script #!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi The run script #!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM # Remove the variables in the .env file from the environment unset $(grep -v '^#' ../.env | sed -E 's/(.*)=.*/\\1/' | xargs) The program. ********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2023-03-08 dscobol Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program.","title":"My version of CUSTINQ accepting Environment Variable set from a .env file"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/#my-version-of-custinq-accepting-environment-variable-set-from-a-env-file","text":"From the user's perspective, the result is the same. It is only the structure of the program that is different.","title":"My version of CUSTINQ accepting Environment Variable set from a .env file"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/#the-env-file","text":"# DB1 Connection parameters db2name=names username=userid password=passwd","title":"The .env file"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/#the-compile-script","text":"#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # DB2 Load Libraries export LOADLIB=\"$DB2_HOME/lib64\" # COBOL and SQL Copy Libraries export COBCOPY=\"../cpy\" export SQLCOPY=\"$DB2_HOME/include/cobol_mf\" # Delete previous versions rm ../cbl/$PGM.bnd rm ../tcbl/$PGM.cbl rm ../bin/$PGM # DB2 Prep and Bind db2 -tvf ../sql/$PGM.sql read -p \"Press any key to resume\" # Compile cobc -std=default -x -o ../bin/$PGM ../tcbl/$PGM.cbl \\ -static \\ -I $SQLCOPY \\ -I $COBCOPY \\ -L $LOADLIB \\ -l db2 \\ -Wall \\ -O # Check return code if [ \"$?\" -eq 0 ]; then echo \"SUCCESS: Compile Return code is ZERO.\" else echo \"FAIL: Compile Return code is NOT ZERO.\" fi","title":"The compile script"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/#the-run-script","text":"#!/bin/bash # Set Up variables # Program to run PGM=CUSTINQ # Export the environment variables in the .env file export $(grep -v '^#' ../.env | xargs) # run program ../bin/$PGM # Remove the variables in the .env file from the environment unset $(grep -v '^#' ../.env | sed -E 's/(.*)=.*/\\1/' | xargs)","title":"The run script"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-accept/#the-program","text":"********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2023-03-08 dscobol Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * DB1 connection parameters. 01 DB1-DBName PIC X(8). 01 DB1-User-ID PIC X(10). 01 DB1-Password. 49 DB1-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 49 DB1-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. ACCEPT DB1-DBName FROM ENVIRONMENT 'db2name'. ACCEPT DB1-User-ID FROM ENVIRONMENT 'username'. ACCEPT DB1-Passwd-Name FROM ENVIRONMENT 'password'. * Passwords in a CONNECT statement should be entered * in a VARCHAR format with the length of the input string. INSPECT DB1-Passwd-Name TALLYING DB1-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". D DISPLAY \"DB1-DBName \" DB1-DBName. D DISPLAY \"DB1-User-ID \" DB1-User-ID. D DISPLAY \"DB1-Passwd-Name \" DB1-Passwd-Name. 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB1-DBName USER :DB1-User-ID USING :DB1-Password END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program.","title":"The program."},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-call/","text":"My version of CUSTINQ calling GETDBID From the user's perspective, the result is the same. It is only the structure of the program that is different. The program. ********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2020-09-03 dastagg Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 WS-Called-Programs. 12 WS-GetDBId PIC X(8) VALUE SPACES. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. MOVE 'GETDBID' TO WS-GetDBId CALL WS-GetDBId USING DB-User-ID, DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program.","title":"My version of CUSTINQ calling GETDBID"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-call/#my-version-of-custinq-calling-getdbid","text":"From the user's perspective, the result is the same. It is only the structure of the program that is different.","title":"My version of CUSTINQ calling GETDBID"},{"location":"guides/gnu-vs-zos-cobol/db2/my-version-of-custinq-with-call/#the-program","text":"********************************************************** * Program name: CUSTINQ * Original author: David Stagowski * * Description: Query the Customer table. * * Maintenance Log * Date Author Maintenance Requirement * ---------- ------------ -------------------------------- * 2020-09-03 dastagg Created to learn. * 20XX-XX-XX If you change me, change this. * ********************************************************** IDENTIFICATION DIVISION. PROGRAM-ID. CUSTINQ. ENVIRONMENT DIVISION. CONFIGURATION SECTION. * SOURCE-COMPUTER. IBM WITH DEBUGGING MODE. DATA DIVISION. WORKING-STORAGE SECTION. EXEC SQL INCLUDE SQLCA END-EXEC. EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 HV-Customer-Row. 12 HV-Cust-Number PIC X(06). 12 HV-Cust-First-Name PIC X(20). 12 HV-Cust-Last-Name PIC X(30). 12 HV-Cust-Address PIC X(30). 12 HV-Cust-City PIC X(20). 12 HV-Cust-State PIC X(02). 12 HV-Cust-ZipCode PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. ******************* 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. 01 WS-Application-Flags. 12 WS-Inquiry-Flag PIC X. 88 WS-Keep-Looking VALUE 'Y'. 88 WS-Stop-Looking VALUE 'N'. 12 WS-Find-Customer-Flag PIC X. 88 WS-Customer-Found VALUE 'Y'. 88 WS-Customer-Not-Found VALUE 'N'. 01 WS-Called-Programs. 12 WS-GetDBId PIC X(8) VALUE SPACES. 01 EOJ-Display-Messages. 12 EOJ-End-Message PIC X(042) VALUE \"*** Program CUSTINQ - End of Run Messages\". PROCEDURE DIVISION. 0000-Mainline. PERFORM 1000-Begin-Job. PERFORM 2000-Process. PERFORM 3000-End-Job. GOBACK. 1000-Begin-Job. PERFORM 9800-Connect-to-DB1. IF SQL-STATUS-OK SET WS-Keep-Looking TO TRUE END-IF. 2000-Process. PERFORM 2100-Display-Customer UNTIL WS-Stop-Looking. 2100-Display-Customer. PERFORM 2110-Accept-Customer-Number. IF WS-Keep-Looking PERFORM 2120-Get-Customer-Row IF WS-Customer-Found PERFORM 2130-Display-Customer-Lines ELSE PERFORM 2140-Display-Error-Lines END-IF END-IF. 2110-Accept-Customer-Number. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY 'Key in the next Customer Number and press Enter,'. DISPLAY 'or key in 999999 and press Enter to quit.'. ACCEPT HV-Cust-Number. IF HV-Cust-Number = '999999' SET WS-Stop-Looking TO TRUE END-IF. 2120-Get-Customer-Row. PERFORM 5000-Read-DB1. 2130-Display-Customer-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number. DISPLAY ' Name: ' FUNCTION TRIM(HV-Cust-First-Name), SPACE, FUNCTION TRIM(HV-Cust-Last-Name). DISPLAY ' Address: ' FUNCTION TRIM(HV-Cust-Address). DISPLAY ' ' FUNCTION TRIM(HV-Cust-City), SPACE, HV-Cust-State, SPACE, HV-Cust-ZipCode. DISPLAY '-------------------------------------------------'. 2140-Display-Error-Lines. DISPLAY '-------------Customer Inquiry--------------------'. DISPLAY '-------------------------------------------------'. DISPLAY ' Customer: ' HV-Cust-Number ' was not found.'. 3000-End-Job. EXEC SQL CONNECT RESET END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 5000-Read-DB1. EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :HV-Cust-Number, :HV-Cust-First-Name, :HV-Cust-Last-Name, :HV-Cust-Address, :HV-Cust-City, :HV-Cust-State, :HV-Cust-ZipCode FROM CUSTOMERS WHERE CUSTNO = :HV-Cust-Number END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. IF SQL-STATUS-OK SET WS-Customer-Found TO TRUE ELSE IF SQL-STATUS-NOT-FOUND SET WS-Customer-Not-Found TO TRUE ELSE DISPLAY \"*** WARNING ***\" DISPLAY \"There was a problem Fetching the cursor.\" DISPLAY \"SQLCODE = \" SQLCODE PERFORM 3000-End-Job MOVE 8 TO RETURN-CODE GOBACK END-IF END-IF. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. MOVE 'GETDBID' TO WS-GetDBId CALL WS-GetDBId USING DB-User-ID, DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK PERFORM 9816-Create-Cursor-DB1 IF SQL-STATUS-OK PERFORM 9818-Open-Cursor-DB1 END-IF END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS. 9816-Create-Cursor-DB1. * Parms for DB1-C1 *D DISPLAY \"Nothing to do here.\". * As an example: * MOVE \"DESIGNER\" TO HV-Job-Title. 9818-Open-Cursor-DB1. * This would be where you open a cursor. * Not needed for this program.","title":"The program."},{"location":"guides/gnu-vs-zos-cobol/db2/normal-db2-zos-cobol/","text":"An example of a normal DB2 ZOS COBOL program This is the CUSTINQ program from the Murach book: IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. * EXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC. * PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM MM01.CUSTOMER WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * This is the code from the WORKING-STORAGE SECTION. EXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC. Notes about this code: Within \"INCLUDE CUSTOMER\", CUSTOMER is the DCLGEN generated copybook member \"CUSTOMER\" has two areas: A \"EXEC SQL DECLARE CUSTOMER TABLE area which lists each column name and data type in the table BUT the data type is a SQL data type, not a COBOL data type. A COBOL declaration of 01-CUSTOMER-ROW which lists each column name and data type in the table BUT the data type is a COBOL data type, not a SQL data type.","title":"An example of a normal DB2 ZOS COBOL program"},{"location":"guides/gnu-vs-zos-cobol/db2/normal-db2-zos-cobol/#an-example-of-a-normal-db2-zos-cobol-program","text":"This is the CUSTINQ program from the Murach book: IDENTIFICATION DIVISION. * PROGRAM-ID. CUSTINQ. * ENVIRONMENT DIVISION. * INPUT-OUTPUT SECTION. * FILE-CONTROL. * DATA DIVISION. * FILE SECTION. * WORKING-STORAGE SECTION. * 01 SWITCHES. * 05 END-OF-INQUIRIES-SW PIC X VALUE 'N'. 88 END-OF-INQUIRIES VALUE 'Y'. 05 CUSTOMER-FOUND-SW PIC X. 88 CUSTOMER-FOUND VALUE 'Y'. * EXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC. * PROCEDURE DIVISION. * 000-DISPLAY-CUSTOMER-ROWS. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. * 100-DISPLAY-CUSTOMER-ROW. * PERFORM 110-ACCEPT-CUSTOMER-NUMBER. IF NOT END-OF-INQUIRIES MOVE 'Y' TO CUSTOMER-FOUND-SW PERFORM 120-GET-CUSTOMER-ROW IF CUSTOMER-FOUND PERFORM 130-DISPLAY-CUSTOMER-LINES ELSE PERFORM 140-DISPLAY-ERROR-LINES. * 110-ACCEPT-CUSTOMER-NUMBER. * DISPLAY '------------------------------------------------'. DISPLAY 'KEY IN THE NEXT CUSTOMER NUMBER AND PRESS ENTER,'. DISPLAY 'OR KEY IN 999999 AND PRESS ENTER TO QUIT.'. ACCEPT CUSTNO. IF CUSTNO = '999999' MOVE 'Y' TO END-OF-INQUIRIES-SW. * 120-GET-CUSTOMER-ROW. * EXEC SQL SELECT CUSTNO, FNAME, LNAME, ADDR, CITY, STATE, ZIPCODE INTO :CUSTNO, :FNAME, :LNAME, :ADDR, :CITY, :STATE, :ZIPCODE FROM MM01.CUSTOMER WHERE CUSTNO = :CUSTNO END-EXEC. * IF SQLCODE NOT = 0 MOVE 'N' TO CUSTOMER-FOUND-SW. * 130-DISPLAY-CUSTOMER-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER ' CUSTNO. DISPLAY ' NAME ' FNAME ' ' LNAME. DISPLAY ' ADDRESS ' ADDR. DISPLAY ' ' CITY ' ' STATE ' ' ZIPCODE. * 140-DISPLAY-ERROR-LINES. * DISPLAY '------------------------------------------------'. DISPLAY ' CUSTOMER NUMBER ' CUSTNO ' NOT FOUND.'. * This is the code from the WORKING-STORAGE SECTION. EXEC SQL INCLUDE CUSTOMER END-EXEC. * EXEC SQL INCLUDE SQLCA END-EXEC.","title":"An example of a normal DB2 ZOS COBOL program"},{"location":"guides/gnu-vs-zos-cobol/db2/normal-db2-zos-cobol/#notes-about-this-code","text":"Within \"INCLUDE CUSTOMER\", CUSTOMER is the DCLGEN generated copybook member \"CUSTOMER\" has two areas: A \"EXEC SQL DECLARE CUSTOMER TABLE area which lists each column name and data type in the table BUT the data type is a SQL data type, not a COBOL data type. A COBOL declaration of 01-CUSTOMER-ROW which lists each column name and data type in the table BUT the data type is a COBOL data type, not a SQL data type.","title":"Notes about this code:"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/","text":"zOS COBOL/DB2 vs GnuCOBOL/DB2 LUW zOS COBOL/DB2 RACF - the security system DCLGEN - Create an INCLUDE copybook member that defines the table and adds host variables. GnuCOBOL/DB2 LUW No RACF. Since there is no RACF, the DB name, the userid, and the password must be supplied to the program for it to connect to the DB. There is a db2dclgn command included with IBM DB2 LUW but it does not generate the table definition within a \"EXEC SQL DECLARE\" statement. It only defines the COBOL host variables. So, you have to create the EXEC SQL DECLARE \"xxxxx\" TABLE statement, the host variables, and the DB Connect variables within the program itself. TL/DR: 3 different methods in the repository to supply the program with the DB parameters? A look at the examples to see the differences: Original Code from Murach book This is an example of a Normal ZOS COBOL DB2 program. In the repository on GitHub, this is cbl/CUSTINQ.cbl It will not compile with GnuCOBOL. Also, as I'm not sure about the copyright and my ability to \"re-distribute\" the code included in the book, this will the only time I will include the exact original code from the book. I will be using it 3 more times (Version 1, 2 and 3) but those have changes made to them to compile and run using GnuCOBOL. As you will see in Versions 4 and 5, I have my own program structure and style and while the results will be the same as the original, the code will be quite different. Version 1 This is an example of a Converted from ZOS to GnuCOBOL program. In the repository on GitHub, this is cbl/CUSTIN1.sqb I started with cbl/CUSTINQ.cbl and: removed the INCLUDE CUSTOMER statement added the EXEC SQL DECLARE TABLE statement added the host variables and the DB Connect variables added Procedure code to use ACCEPT to get the userid and password from the user when the program is run. Version 2 This is an example of Calling a Module program. In the repository on GitHub, this is cbl/CUSTIN2.sqb I started with cbl/CUSTIN1.sqb and: created GETDBID program to \"hardcode\" the userid and password. updated to call GETDBID and removed the ACCEPT from User code. updated the Compile script to add GETDBID LLM to the compile step. Now the program will run without needing to ask the user for that information. Version 3 This is an example of Accept from Environment program. In the repository on GitHub, this is cbl/CUSTIN3.sqb I started with cbl/CUSTIN2.sqb created a .env file with the parameters for the DB. removed GETDBID program. updated to ACCEPT FROM ENVIRONMENT code. updated the Compile script to remove GETDBID LLM from the compile step. updated the Run script to export the parameters from the .env file to the Environment Variables. This program will also run without needing to ask the user for the DB parameters. Version 4 This is an example of My version of Calling GETDBID . In the repository on GitHub, this is cbl/CUSTIN4.sqb As I alluded to in Version 1, this is that completely re-written program. Here's the thing, when I went to school, I completed all the programming assignments, got very good grades and all the professors said I was prepared to get a job as a programmer. At the first job, I was told what I would be doing and was given the name of the program I would work on. I logon to TSO/ISPF, go to the PDS, open the member, start reading it and thought, \"What is this? It looks similar to what I created in school but it is really, really different.\" Every company has a standard and/or style that all(most?) code adheres to. At some shops, it is kind of loose, at others, it is VERY rigid. This is an example of getting the same result; just doing it a different way by applying a different structure to the program. As I continue to add programs to the repositories, they will \"follow along\" with the book or tutorial or website but will be using this structure. Version 5 This is an example of My version of Accept from Environment . In the repository on GitHub, this is cbl/CUSTINQ.sqb Just as CUSTIN2 was converted into CUSTIN3 by replacing the \"CALL to GETDBID\" with \"ACCEPT FROM ENVIRONMENT\", this is CUSTIN4 converted into CUSTINQ the same way.","title":"Overview"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#zos-coboldb2-vs-gnucoboldb2-luw","text":"","title":"zOS COBOL/DB2 vs GnuCOBOL/DB2 LUW"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#zos-coboldb2","text":"RACF - the security system DCLGEN - Create an INCLUDE copybook member that defines the table and adds host variables.","title":"zOS COBOL/DB2"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#gnucoboldb2-luw","text":"No RACF. Since there is no RACF, the DB name, the userid, and the password must be supplied to the program for it to connect to the DB. There is a db2dclgn command included with IBM DB2 LUW but it does not generate the table definition within a \"EXEC SQL DECLARE\" statement. It only defines the COBOL host variables. So, you have to create the EXEC SQL DECLARE \"xxxxx\" TABLE statement, the host variables, and the DB Connect variables within the program itself.","title":"GnuCOBOL/DB2 LUW"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#tldr-3-different-methods-in-the-repository-to-supply-the-program-with-the-db-parameters","text":"","title":"TL/DR: 3 different methods in the repository to supply the program with the DB parameters?"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#a-look-at-the-examples-to-see-the-differences","text":"","title":"A look at the examples to see the differences:"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#original-code-from-murach-book","text":"This is an example of a Normal ZOS COBOL DB2 program. In the repository on GitHub, this is cbl/CUSTINQ.cbl It will not compile with GnuCOBOL. Also, as I'm not sure about the copyright and my ability to \"re-distribute\" the code included in the book, this will the only time I will include the exact original code from the book. I will be using it 3 more times (Version 1, 2 and 3) but those have changes made to them to compile and run using GnuCOBOL. As you will see in Versions 4 and 5, I have my own program structure and style and while the results will be the same as the original, the code will be quite different.","title":"Original Code from Murach book"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#version-1","text":"This is an example of a Converted from ZOS to GnuCOBOL program. In the repository on GitHub, this is cbl/CUSTIN1.sqb I started with cbl/CUSTINQ.cbl and: removed the INCLUDE CUSTOMER statement added the EXEC SQL DECLARE TABLE statement added the host variables and the DB Connect variables added Procedure code to use ACCEPT to get the userid and password from the user when the program is run.","title":"Version 1"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#version-2","text":"This is an example of Calling a Module program. In the repository on GitHub, this is cbl/CUSTIN2.sqb I started with cbl/CUSTIN1.sqb and: created GETDBID program to \"hardcode\" the userid and password. updated to call GETDBID and removed the ACCEPT from User code. updated the Compile script to add GETDBID LLM to the compile step. Now the program will run without needing to ask the user for that information.","title":"Version 2"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#version-3","text":"This is an example of Accept from Environment program. In the repository on GitHub, this is cbl/CUSTIN3.sqb I started with cbl/CUSTIN2.sqb created a .env file with the parameters for the DB. removed GETDBID program. updated to ACCEPT FROM ENVIRONMENT code. updated the Compile script to remove GETDBID LLM from the compile step. updated the Run script to export the parameters from the .env file to the Environment Variables. This program will also run without needing to ask the user for the DB parameters.","title":"Version 3"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#version-4","text":"This is an example of My version of Calling GETDBID . In the repository on GitHub, this is cbl/CUSTIN4.sqb As I alluded to in Version 1, this is that completely re-written program. Here's the thing, when I went to school, I completed all the programming assignments, got very good grades and all the professors said I was prepared to get a job as a programmer. At the first job, I was told what I would be doing and was given the name of the program I would work on. I logon to TSO/ISPF, go to the PDS, open the member, start reading it and thought, \"What is this? It looks similar to what I created in school but it is really, really different.\" Every company has a standard and/or style that all(most?) code adheres to. At some shops, it is kind of loose, at others, it is VERY rigid. This is an example of getting the same result; just doing it a different way by applying a different structure to the program. As I continue to add programs to the repositories, they will \"follow along\" with the book or tutorial or website but will be using this structure.","title":"Version 4"},{"location":"guides/gnu-vs-zos-cobol/db2/overview-db2-zos-vs-gnucobol/#version-5","text":"This is an example of My version of Accept from Environment . In the repository on GitHub, this is cbl/CUSTINQ.sqb Just as CUSTIN2 was converted into CUSTIN3 by replacing the \"CALL to GETDBID\" with \"ACCEPT FROM ENVIRONMENT\", this is CUSTIN4 converted into CUSTINQ the same way.","title":"Version 5"},{"location":"guides/gnu-vs-zos-cobol/db2/specific-changes-for-gnucobol/","text":"An overview of the specific changes made to make it run using GnuCOBOL Since DCLGEN isn't the same on IBM DB2 LUW, create that ***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1 Add the PERFORM paragraph 000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. Then add the 9800-Connect-to DB1 and friends paragraphs * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"An overview of the specific changes made to make it run using GnuCOBOL"},{"location":"guides/gnu-vs-zos-cobol/db2/specific-changes-for-gnucobol/#an-overview-of-the-specific-changes-made-to-make-it-run-using-gnucobol","text":"","title":"An overview of the specific changes made to make it run using GnuCOBOL"},{"location":"guides/gnu-vs-zos-cobol/db2/specific-changes-for-gnucobol/#since-dclgen-isnt-the-same-on-ibm-db2-luw-create-that","text":"***** Convert to GnuCOBOL ***** Start of Step 1 * No DCLGEN member to INCLUDE * Comment this INCLUDE out * EXEC SQL * INCLUDE CUSTOMER * END-EXEC. * * Add DECLARE TABLE EXEC SQL DECLARE CUSTOMERS TABLE ( CUSTNO CHAR(6) not null, FNAME CHAR(20) not null, LNAME CHAR(30) not null, ADDR CHAR(30) not null, CITY CHAR(20) not null, STATE CHAR(2) not null, ZIPCODE CHAR(10) not null) END-EXEC. * Add DECLARE SECTION EXEC SQL BEGIN DECLARE SECTION END-EXEC. 01 Customer-Row. 12 CUSTNO PIC X(06). 12 FNAME PIC X(20). 12 LNAME PIC X(30). 12 ADDR PIC X(30). 12 CITY PIC X(20). 12 STATE PIC X(02). 12 ZIPCODE PIC X(10). * This is hardcoded for the MURACH DB. * You might need to update this for your DB. 01 DB-Connection-Info. 12 DB-Alias PIC X(8) VALUE 'MURACH'. 12 DB-User-ID PIC X(10). 12 DB-Password. 15 DB-Passwd-Length PIC S9(4) COMP-5 VALUE 0. 15 DB-Passwd-Name PIC X(18). EXEC SQL END DECLARE SECTION END-EXEC. * Add status check for connection info. 01 WS-SQL-STATUS PIC S9(9) COMP-5. 88 SQL-STATUS-OK VALUE 0. 88 SQL-STATUS-NOT-FOUND VALUE 100. 88 SQL-STATUS-DUP VALUE -803. ***** End of Step 1","title":"Since DCLGEN isn't the same on IBM DB2 LUW, create that"},{"location":"guides/gnu-vs-zos-cobol/db2/specific-changes-for-gnucobol/#add-the-perform-paragraph","text":"000-DISPLAY-CUSTOMER-ROWS. * Step 2 * Add Paragraph to connect to the DB PERFORM 9800-Connect-to-DB1. * PERFORM 100-DISPLAY-CUSTOMER-ROW UNTIL END-OF-INQUIRIES. STOP RUN. Then add the 9800-Connect-to DB1 and friends paragraphs * Step 2 - the actual connection. 9800-Connect-to-DB1. PERFORM 9810-Setup-DB1-Connection. IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"*** The DB connection is not valid!***\" DISPLAY \"Exiting the program.!\" GOBACK END-IF. 9810-Setup-DB1-Connection. PERFORM 9811-Get-Credentials. PERFORM 9812-Create-Connection-To-DB1. 9811-Get-Credentials. DISPLAY \"CUSTINQ: Need userid and password\". DISPLAY \"Enter your user id (default none): \" WITH NO ADVANCING. ACCEPT DB-User-ID. DISPLAY \"Enter your password : \" WITH NO ADVANCING ACCEPT DB-Passwd-Name. * Passwords in a CONNECT statement must be entered in a VARCHAR * format with the length of the input string. INSPECT DB-Passwd-Name TALLYING DB-Passwd-Length FOR CHARACTERS BEFORE INITIAL \" \". 9812-Create-Connection-To-DB1. PERFORM 9814-Connect-To-DB1 IF SQL-STATUS-OK CONTINUE ELSE DISPLAY \"CUSTINQ: userid and/or password invalid\" DISPLAY \"CUSTINQ: Can not connect, exiting\" GOBACK END-IF. 9814-Connect-To-DB1. EXEC SQL CONNECT TO :DB-Alias USER :DB-User-ID USING :DB-Passwd-Name END-EXEC. MOVE SQLCODE TO WS-SQL-STATUS.","title":"Add the PERFORM paragraph"},{"location":"guides/ibm-db2-luw/create-db2-db/","text":"Create a new DB2 database Become Instance Owner During the install of IBM DB2 LUW, if you accepted the defaults, the Instance Owner's userid is \"db2inst1\". If you changed that, use that userid instead. To create new databases, you have to become the Instance Owner and get into the DB2 system. Run: su - db2inst1 Enter the password. This will make you \"db2inst1\" and display a very bare prompt Run: ksh to get a more useable environment. Run: db2 This gets you \"into the DB2 system\". Create a new database and call it MURACH. Because there are tables used in Murach books that have the same names as the Sample DB, create the MURACH DB. Follow the instructions above to \"get into the db2 system\", then: At the db2> prompt, Run CREATE DATABASE MURACH You might wait a very long time but it should come back with \"successfully created database\" Create a new database and call it BOOKS. Create the BOOKS DB. Follow the instructions above to \"get into the db2 system\", then: At the db2> prompt, Run CREATE DATABASE BOOKS You might wait a very long time but it should come back with \"successfully created database\"","title":"Create a DB2 DB"},{"location":"guides/ibm-db2-luw/create-db2-db/#create-a-new-db2-database","text":"","title":"Create a new DB2 database"},{"location":"guides/ibm-db2-luw/create-db2-db/#become-instance-owner","text":"During the install of IBM DB2 LUW, if you accepted the defaults, the Instance Owner's userid is \"db2inst1\". If you changed that, use that userid instead. To create new databases, you have to become the Instance Owner and get into the DB2 system. Run: su - db2inst1 Enter the password. This will make you \"db2inst1\" and display a very bare prompt Run: ksh to get a more useable environment. Run: db2 This gets you \"into the DB2 system\".","title":"Become Instance Owner"},{"location":"guides/ibm-db2-luw/create-db2-db/#create-a-new-database-and-call-it-murach","text":"Because there are tables used in Murach books that have the same names as the Sample DB, create the MURACH DB. Follow the instructions above to \"get into the db2 system\", then: At the db2> prompt, Run CREATE DATABASE MURACH You might wait a very long time but it should come back with \"successfully created database\"","title":"Create a new database and call it MURACH."},{"location":"guides/ibm-db2-luw/create-db2-db/#create-a-new-database-and-call-it-books","text":"Create the BOOKS DB. Follow the instructions above to \"get into the db2 system\", then: At the db2> prompt, Run CREATE DATABASE BOOKS You might wait a very long time but it should come back with \"successfully created database\"","title":"Create a new database and call it BOOKS."},{"location":"guides/ibm-db2-luw/install-db2/","text":"Install IBM DB2 LUW RDBMS If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Get the software Open Firefox and visit IBM DB2 Products page . Click on the \"Download IBM Db2 Software Community Edition\" link. You will need an IBM account to download the software. There is no cost to create an account and there is no cost to download and run the Db2 Community Edition. Enter all the information it needs. You might have to log back in with your new IBM ID or it may take you to the next page. You will be presented with some marketing stuff. Choose your options and press the Continue button. Since this will be installed on a Linux system, click the download link for \"Linux (x64)\". This will download the file \"v11.5.8_linuxx64_server_dec.tar.gz\". If you didn't change anything, the default location for downloads is \"~/Downloads\". This is okay. Prep for building the software Setup the directory structure People have different ways of setting up the structure in the home directory. When the OS was created, by default, the following directories were created: . \u251c\u2500\u2500 Desktop \u251c\u2500\u2500 Documents \u251c\u2500\u2500 Downloads \u251c\u2500\u2500 Music \u251c\u2500\u2500 Pictures \u251c\u2500\u2500 Public \u251c\u2500\u2500 Templates \u2514\u2500\u2500 Videos Open Terminal and add three more directories, Run: cd mkdir bin builds dev The bin and dev directories will be useful later but for now we will focus on the builds directory. Extract the downloaded file Open Files and go to the Downloads folder. Double click on the v11.5.8_linuxx64_server_dec.tar.gz file. This will open Archive Manager. After a little while, within that, you will see \"server_dec\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files. Rename the directory In Terminal, Run: cd cd builds to go to the builds directory. Make sure the server_dec directory is present, Run: ls Rename server_dec to ibm-db2, Run: mv server_dec ibm-db2 Enter the ibm-db2 directory, Run: cd ibm-db2 Install additional software In Terminal, Run the following commands to install additional software needed to run IBM DB2 LUW: sudo apt install build-essential sudo apt install libaio1 sudo dpkg --add-architecture i386 sudo apt install libstdc++6:i386 sudo apt install libpam0g:i386 sudo apt install ksh Checking Prerequisites Run: ./db2prereqcheck If you went with Pop!_OS, this will fail with a message about \"couldn't recognize the distribution\". Don't worry, it will work. If you installed Ubuntu instead of Pop!_OS, you will see a long list of information and at the bottom it will say that all requrements are met. Installing IBM DB2 LUW as a \"root\" or \"system\" install Run: sudo ./db2setup -f sysreq If you installed Ubuntu instead, Run sudo ./db2setup This will open a small dialog window. Click on New Install Make sure DB2 Version 11.5.8.0 Server Editions is highlighted Purescale is not available on Ubuntu Click Next When you get to the window that has two buttons: Typical or Custom Select Custom Check the box that you agree to the Licence Click Next When presented with \"Select Features\": Within Application development tools: Check \"Base application development tools\" Click Next Go through the rest of the windows accepting the defaults until you see \"Instance Owner\". The next two windows set the password for new userids: db2inst1 and db2fenc1 For the remaining windows, accept the defaults. Note: Port number is 25000. Go through the rest of the windows accepting the defaults until you see \"Response File and Summary\". Click Finish The install process will start and when it finishes, look through the log file. All should look good except \"Installing TSAMP\". There is a warning for this. Click Finish To be on the safe side, restart after the install is finished. When it reboots, there should be three users to select from on the login window. The \"normal\" userid (the one created when the OS was installed), and the db2inst1 and db2fenc1 userids. Log in with the \"normal\" userid and open Terminal and Run: cd /opt/ibm/db2/V11.5/ Look at the include and samples directories and make sure all the COBOL stuff is present.","title":"Install DB2 LUW"},{"location":"guides/ibm-db2-luw/install-db2/#install-ibm-db2-luw-rdbms","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Install IBM DB2 LUW RDBMS"},{"location":"guides/ibm-db2-luw/install-db2/#get-the-software","text":"Open Firefox and visit IBM DB2 Products page . Click on the \"Download IBM Db2 Software Community Edition\" link. You will need an IBM account to download the software. There is no cost to create an account and there is no cost to download and run the Db2 Community Edition. Enter all the information it needs. You might have to log back in with your new IBM ID or it may take you to the next page. You will be presented with some marketing stuff. Choose your options and press the Continue button. Since this will be installed on a Linux system, click the download link for \"Linux (x64)\". This will download the file \"v11.5.8_linuxx64_server_dec.tar.gz\". If you didn't change anything, the default location for downloads is \"~/Downloads\". This is okay.","title":"Get the software"},{"location":"guides/ibm-db2-luw/install-db2/#prep-for-building-the-software","text":"","title":"Prep for building the software"},{"location":"guides/ibm-db2-luw/install-db2/#setup-the-directory-structure","text":"People have different ways of setting up the structure in the home directory. When the OS was created, by default, the following directories were created: . \u251c\u2500\u2500 Desktop \u251c\u2500\u2500 Documents \u251c\u2500\u2500 Downloads \u251c\u2500\u2500 Music \u251c\u2500\u2500 Pictures \u251c\u2500\u2500 Public \u251c\u2500\u2500 Templates \u2514\u2500\u2500 Videos Open Terminal and add three more directories, Run: cd mkdir bin builds dev The bin and dev directories will be useful later but for now we will focus on the builds directory.","title":"Setup the directory structure"},{"location":"guides/ibm-db2-luw/install-db2/#extract-the-downloaded-file","text":"Open Files and go to the Downloads folder. Double click on the v11.5.8_linuxx64_server_dec.tar.gz file. This will open Archive Manager. After a little while, within that, you will see \"server_dec\". Click on the \"Extract\" button in the upper left hand corner. A dialog box will open to select where to extract the file to. Extract the file to the ~/builds directory. When it is done, close the dialog box, close Archive Manager, and close Files.","title":"Extract the downloaded file"},{"location":"guides/ibm-db2-luw/install-db2/#rename-the-directory","text":"In Terminal, Run: cd cd builds to go to the builds directory. Make sure the server_dec directory is present, Run: ls Rename server_dec to ibm-db2, Run: mv server_dec ibm-db2 Enter the ibm-db2 directory, Run: cd ibm-db2","title":"Rename the directory"},{"location":"guides/ibm-db2-luw/install-db2/#install-additional-software","text":"In Terminal, Run the following commands to install additional software needed to run IBM DB2 LUW: sudo apt install build-essential sudo apt install libaio1 sudo dpkg --add-architecture i386 sudo apt install libstdc++6:i386 sudo apt install libpam0g:i386 sudo apt install ksh","title":"Install additional software"},{"location":"guides/ibm-db2-luw/install-db2/#checking-prerequisites","text":"Run: ./db2prereqcheck If you went with Pop!_OS, this will fail with a message about \"couldn't recognize the distribution\". Don't worry, it will work. If you installed Ubuntu instead of Pop!_OS, you will see a long list of information and at the bottom it will say that all requrements are met.","title":"Checking Prerequisites"},{"location":"guides/ibm-db2-luw/install-db2/#installing-ibm-db2-luw-as-a-root-or-system-install","text":"Run: sudo ./db2setup -f sysreq If you installed Ubuntu instead, Run sudo ./db2setup This will open a small dialog window. Click on New Install Make sure DB2 Version 11.5.8.0 Server Editions is highlighted Purescale is not available on Ubuntu Click Next When you get to the window that has two buttons: Typical or Custom Select Custom Check the box that you agree to the Licence Click Next When presented with \"Select Features\": Within Application development tools: Check \"Base application development tools\" Click Next Go through the rest of the windows accepting the defaults until you see \"Instance Owner\". The next two windows set the password for new userids: db2inst1 and db2fenc1 For the remaining windows, accept the defaults. Note: Port number is 25000. Go through the rest of the windows accepting the defaults until you see \"Response File and Summary\". Click Finish The install process will start and when it finishes, look through the log file. All should look good except \"Installing TSAMP\". There is a warning for this. Click Finish To be on the safe side, restart after the install is finished. When it reboots, there should be three users to select from on the login window. The \"normal\" userid (the one created when the OS was installed), and the db2inst1 and db2fenc1 userids. Log in with the \"normal\" userid and open Terminal and Run: cd /opt/ibm/db2/V11.5/ Look at the include and samples directories and make sure all the COBOL stuff is present.","title":"Installing IBM DB2 LUW as a \"root\" or \"system\" install"},{"location":"guides/ibm-db2-luw/install-sampledb/","text":"Install the Sample DB. If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Check the installation In Terminal, Run: su - db2inst1 ksh You will need to enter the password for db2inst1 after the su command. Use ksh for a \"more useable\" command line. A quick check, Run: db2 list database directory returns no DBs. Validate the install Run: cd sqllib/bin Run: ./db2val This should return: \"The instance validation for the instance db2inst1 was successful.\" Install Sample DB While still in the sqllib/bin directory, Run: ./db2sampl to create the Sample DB. Not sure why but this takes a LLLLOOOONNNNGGGG time to complete. To check success, Run: db2 list database directory This should return: System Database Directory Number of entries in the directory = 1 Database 1 entry: Database alias = SAMPLE Database name = SAMPLE Local database directory = /home/db2inst1 Database release level = 15.00 Comment = Directory entry type = Indirect Catalog database partition number = 0 Alternate server hostname = Alternate server port number = Now Run: db2 This will take you inside DB2 and provide the DB2 prompt. Then Run: connect to sample This will return: Database Connection Information Database server = DB2/LINUXX8664 11.5.8.0 SQL authorization ID = DB2INST1 Local database alias = SAMPLE Then Run: select * from employee This will return a listing of 42 employees Run: quit to exit DB2 and return to the command prompt. Then Run twice: exit to exit the ksh shell and exit db2inst1 and become the \"normal\" user again. Install db2profile in .bashrc As the \"normal\" user, you will need to run some DB2 commands in Terminal. To make this possible, add the following 4 lines to the bottom of the .bashrc file which is found in the home directory. # The following three lines have been added by UDB DB2. if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profile fi This will also export some very useful environment variables. You will need to exit and re-open Terminal for them to be activated.","title":"Install Sample DB and db2profile"},{"location":"guides/ibm-db2-luw/install-sampledb/#install-the-sample-db","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Install the Sample DB."},{"location":"guides/ibm-db2-luw/install-sampledb/#check-the-installation","text":"In Terminal, Run: su - db2inst1 ksh You will need to enter the password for db2inst1 after the su command. Use ksh for a \"more useable\" command line. A quick check, Run: db2 list database directory returns no DBs.","title":"Check the installation"},{"location":"guides/ibm-db2-luw/install-sampledb/#validate-the-install","text":"Run: cd sqllib/bin Run: ./db2val This should return: \"The instance validation for the instance db2inst1 was successful.\"","title":"Validate the install"},{"location":"guides/ibm-db2-luw/install-sampledb/#install-sample-db","text":"While still in the sqllib/bin directory, Run: ./db2sampl to create the Sample DB. Not sure why but this takes a LLLLOOOONNNNGGGG time to complete. To check success, Run: db2 list database directory This should return: System Database Directory Number of entries in the directory = 1 Database 1 entry: Database alias = SAMPLE Database name = SAMPLE Local database directory = /home/db2inst1 Database release level = 15.00 Comment = Directory entry type = Indirect Catalog database partition number = 0 Alternate server hostname = Alternate server port number = Now Run: db2 This will take you inside DB2 and provide the DB2 prompt. Then Run: connect to sample This will return: Database Connection Information Database server = DB2/LINUXX8664 11.5.8.0 SQL authorization ID = DB2INST1 Local database alias = SAMPLE Then Run: select * from employee This will return a listing of 42 employees Run: quit to exit DB2 and return to the command prompt. Then Run twice: exit to exit the ksh shell and exit db2inst1 and become the \"normal\" user again.","title":"Install Sample DB"},{"location":"guides/ibm-db2-luw/install-sampledb/#install-db2profile-in-bashrc","text":"As the \"normal\" user, you will need to run some DB2 commands in Terminal. To make this possible, add the following 4 lines to the bottom of the .bashrc file which is found in the home directory. # The following three lines have been added by UDB DB2. if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profile fi This will also export some very useful environment variables. You will need to exit and re-open Terminal for them to be activated.","title":"Install db2profile in .bashrc"},{"location":"guides/ibm-db2-luw/install-vm/","text":"Install a Virtual Machine There are a number of virtualization products available to create a Virtual Machine on your computer: Oracle VM VirtualBox, VMWare, QEMU etc. You may already have one of these installed; if so, go to the next step. If not, pick one of them, and follow the installation instructions for your computer. I use QEMU now but in the past I have used VirtualBox and VMWare. They all work fairly well. Download the Operating System iso Install Pop!_OS Go to the Pop!_OS website press the \"Download\" button. I am using the Pop!_OS 22.04 LTS version. Or use Ubuntu instead As I stated in the overview, Ubuntu is \"offically supported\" so if you want to use that instead: Go to the Ubuntu Desktop website and download the Ubuntu 22.04 LTS version. Three steps to create a VM. Create the VM Follow the instructions for the virtualization product you have installed on your computer to create a VM. Create the \"Harddrive\" that the OS will run on and how big the drive will be. Decide how much memory the VM will be allocated. Other parameters required by the virtualization product. For this project, the parameters I used are: 100GB HD 8GB Ram Install the OS into the VM Follow the instructions for the virtualization product you have installed on your computer to actually install the OS onto the VM harddrive. A word of caution about the userid you create as you install the OS You create a userid when you install the OS and will probably use that userid to run db2 commands. Make sure your userid meets the criteria below: User IDs have the following restrictions and requirements: Must have a primary group other than guests, admins, users, and local. Can include lowercase letters (a-z), numbers (0-9), and the underscore character (_). Cannot be longer than eight characters Cannot begin with IBM, SYS, SQL, or a number. Cannot be a DB2 reserved word (USERS, ADMINS, GUESTS, PUBLIC, or LOCAL), or an SQL reserved word. Cannot use any user IDs with root privilege for the DB2 instance ID, DAS ID, or fenced ID. Cannot include accented characters. This threw me for awhile because I wanted to use \"sysop\" as the userid and then the DB2 LUW install would fail. When done with this step, you usually need to shutdown the VM and then run it so it starts up the installed system and not the iso used to install the system. Run the VM and update Follow the instructions for the virtualization product you have installed on your computer to run the VM. A new window should display with a login screen. Login using the userid you setup when installing the OS. There is a little more Initial Setup, just accept the defaults (or not, your choice) and set the Time Zone. Open the Pop!_Shop application. Click on the \"Installed\" button in the titlebar and then click \"Update All\" in the window listing all the updates that can be done. To be \"safe\", after all the updates are done, restart the system.","title":"Install VM"},{"location":"guides/ibm-db2-luw/install-vm/#install-a-virtual-machine","text":"There are a number of virtualization products available to create a Virtual Machine on your computer: Oracle VM VirtualBox, VMWare, QEMU etc. You may already have one of these installed; if so, go to the next step. If not, pick one of them, and follow the installation instructions for your computer. I use QEMU now but in the past I have used VirtualBox and VMWare. They all work fairly well.","title":"Install a Virtual Machine"},{"location":"guides/ibm-db2-luw/install-vm/#download-the-operating-system-iso","text":"","title":"Download the Operating System iso"},{"location":"guides/ibm-db2-luw/install-vm/#install-pop_os","text":"Go to the Pop!_OS website press the \"Download\" button. I am using the Pop!_OS 22.04 LTS version.","title":"Install Pop!_OS"},{"location":"guides/ibm-db2-luw/install-vm/#or-use-ubuntu-instead","text":"As I stated in the overview, Ubuntu is \"offically supported\" so if you want to use that instead: Go to the Ubuntu Desktop website and download the Ubuntu 22.04 LTS version.","title":"Or use Ubuntu instead"},{"location":"guides/ibm-db2-luw/install-vm/#three-steps-to-create-a-vm","text":"","title":"Three steps to create a VM."},{"location":"guides/ibm-db2-luw/install-vm/#create-the-vm","text":"Follow the instructions for the virtualization product you have installed on your computer to create a VM. Create the \"Harddrive\" that the OS will run on and how big the drive will be. Decide how much memory the VM will be allocated. Other parameters required by the virtualization product. For this project, the parameters I used are: 100GB HD 8GB Ram","title":"Create the VM"},{"location":"guides/ibm-db2-luw/install-vm/#install-the-os-into-the-vm","text":"Follow the instructions for the virtualization product you have installed on your computer to actually install the OS onto the VM harddrive.","title":"Install the OS into the VM"},{"location":"guides/ibm-db2-luw/install-vm/#a-word-of-caution-about-the-userid-you-create-as-you-install-the-os","text":"You create a userid when you install the OS and will probably use that userid to run db2 commands. Make sure your userid meets the criteria below: User IDs have the following restrictions and requirements: Must have a primary group other than guests, admins, users, and local. Can include lowercase letters (a-z), numbers (0-9), and the underscore character (_). Cannot be longer than eight characters Cannot begin with IBM, SYS, SQL, or a number. Cannot be a DB2 reserved word (USERS, ADMINS, GUESTS, PUBLIC, or LOCAL), or an SQL reserved word. Cannot use any user IDs with root privilege for the DB2 instance ID, DAS ID, or fenced ID. Cannot include accented characters. This threw me for awhile because I wanted to use \"sysop\" as the userid and then the DB2 LUW install would fail. When done with this step, you usually need to shutdown the VM and then run it so it starts up the installed system and not the iso used to install the system.","title":"A word of caution about the userid you create as you install the OS"},{"location":"guides/ibm-db2-luw/install-vm/#run-the-vm-and-update","text":"Follow the instructions for the virtualization product you have installed on your computer to run the VM. A new window should display with a login screen. Login using the userid you setup when installing the OS. There is a little more Initial Setup, just accept the defaults (or not, your choice) and set the Time Zone. Open the Pop!_Shop application. Click on the \"Installed\" button in the titlebar and then click \"Update All\" in the window listing all the updates that can be done. To be \"safe\", after all the updates are done, restart the system.","title":"Run the VM and update"},{"location":"guides/ibm-db2-luw/overview/","text":"Overview Let me be blunt. This is not the \"best\" way and it might not be a \"good\" way. It may even be a \"bad\" way and I'm sure that some people will look at this and say: \"Why did you do it \"that\" way?\" But, it does run and it does work. If you have the desire to be able to write COBOL program with embedded SQL statements that access an IBM DB2 LUW RDBMS in a Linux environment... This is \"a\" way. Why this way you ask? I run an Archlinux(ArcoLinux to be precise) system. I can create, compile and run GnuCOBOL programs on that system that run just fine. I haven't installed DB2 on that system, nor do I want to. I have downloaded the Docker DB2 image and can run it but there are problems which I haven't solved yet which prevent me from using that. Lazy of me? Maybe My goal was to learn how to create, compile and run COBOL/DB2 program in a Linux environment. I had a choice of which path to I want to go down first: Fix the problems with Docker or create an Ubuntu VM. I chose the \"Create a VM\" path. IBM DB2 LUW Installation Environment According to the documentation, the only supported Linux environments are RedHat and Ubuntu. Personally, I like the UI for Pop!_OS (by System 76) better and it is based on Ubuntu so I am using that. All the commands work on Ubuntu as well so if you want to use that instead, go for it. You will need to do five things: Create a VM Install IBM DB2 LUW Create the Sample DB Then go to the Dev Tools guide: Install GnuCOBOL Install a Basic Develoment Environment Can I do this in Windows WSL? You may be asking, \"Windows has the WSL that can install an Ubuntu distribution, can I do this within that?\" I have no idea. I have never used WSL so I don't know what it can or cannot do. I do have a Windows 10 system and I have installed IBM DB2 LUW on that, but I use MingGW for DB2 programs and Cygwin for batch programs. Do a search on the GnuCOBOL discussion board for instructions on how to set that up if you want to go that route.","title":"Overview"},{"location":"guides/ibm-db2-luw/overview/#overview","text":"Let me be blunt. This is not the \"best\" way and it might not be a \"good\" way. It may even be a \"bad\" way and I'm sure that some people will look at this and say: \"Why did you do it \"that\" way?\" But, it does run and it does work. If you have the desire to be able to write COBOL program with embedded SQL statements that access an IBM DB2 LUW RDBMS in a Linux environment... This is \"a\" way. Why this way you ask? I run an Archlinux(ArcoLinux to be precise) system. I can create, compile and run GnuCOBOL programs on that system that run just fine. I haven't installed DB2 on that system, nor do I want to. I have downloaded the Docker DB2 image and can run it but there are problems which I haven't solved yet which prevent me from using that. Lazy of me? Maybe My goal was to learn how to create, compile and run COBOL/DB2 program in a Linux environment. I had a choice of which path to I want to go down first: Fix the problems with Docker or create an Ubuntu VM. I chose the \"Create a VM\" path.","title":"Overview"},{"location":"guides/ibm-db2-luw/overview/#ibm-db2-luw-installation-environment","text":"According to the documentation, the only supported Linux environments are RedHat and Ubuntu. Personally, I like the UI for Pop!_OS (by System 76) better and it is based on Ubuntu so I am using that. All the commands work on Ubuntu as well so if you want to use that instead, go for it. You will need to do five things: Create a VM Install IBM DB2 LUW Create the Sample DB Then go to the Dev Tools guide: Install GnuCOBOL Install a Basic Develoment Environment","title":"IBM DB2 LUW Installation Environment"},{"location":"guides/ibm-db2-luw/overview/#can-i-do-this-in-windows-wsl","text":"You may be asking, \"Windows has the WSL that can install an Ubuntu distribution, can I do this within that?\" I have no idea. I have never used WSL so I don't know what it can or cannot do. I do have a Windows 10 system and I have installed IBM DB2 LUW on that, but I use MingGW for DB2 programs and Cygwin for batch programs. Do a search on the GnuCOBOL discussion board for instructions on how to set that up if you want to go that route.","title":"Can I do this in Windows WSL?"},{"location":"guides/postgresql/install-postgresql/","text":"Install PostgreSQL If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Install Follow the instructions on Digital Ocean's Website . One thing I did notice during the install: Data page checksums are disabled. I remember something about \"the checksums require more processing power but insure data integrity\" or something like that. Since this is a dev/test system, I'm not going to worry too much about that. Creating a New Role Follow the Digital Ocean instruction BUT use the \"normal\" userid you created when you created the VM (or system) and say \"y\" to make it a \"superuser\".","title":"Install PostgreSQL"},{"location":"guides/postgresql/install-postgresql/#install-postgresql","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Install PostgreSQL"},{"location":"guides/postgresql/install-postgresql/#install","text":"Follow the instructions on Digital Ocean's Website . One thing I did notice during the install: Data page checksums are disabled. I remember something about \"the checksums require more processing power but insure data integrity\" or something like that. Since this is a dev/test system, I'm not going to worry too much about that.","title":"Install"},{"location":"guides/postgresql/install-postgresql/#creating-a-new-role","text":"Follow the Digital Ocean instruction BUT use the \"normal\" userid you created when you created the VM (or system) and say \"y\" to make it a \"superuser\".","title":"Creating a New Role"},{"location":"guides/postgresql/overview/","text":"Overview If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu. Install PostgreSQL Install PostgreSQL If you want to create GnuCOBOL programs that access a PostgreSQL database, go to the Dev Tools guide: Install GixSQL","title":"Overview"},{"location":"guides/postgresql/overview/#overview","text":"If you created a VM, make sure you are running these steps as the normal user in that VM; not on the host system. These instructions are for Pop!_OS, they should be similar for Ubuntu.","title":"Overview"},{"location":"guides/postgresql/overview/#install-postgresql","text":"Install PostgreSQL If you want to create GnuCOBOL programs that access a PostgreSQL database, go to the Dev Tools guide: Install GixSQL","title":"Install PostgreSQL"},{"location":"guides/zowe-info/getting-started/","text":"dsc-zow-Get-Started: Get Started using Zowe Important NOTE 1 A HLQ of ZAAAAA is used in all the example JCL and scripts. You must change that to your TSO userid for these to work. Important NOTE 2 The JCL contained in these examples is written for the system it was run on. You must verify that the parameters used are valid for the system you are running on. The 3 directories Create Test Dataset Initialize A Project Simple Report Create Test Dataset This demonstrates 3 different ways to create a dataset and then upload the data to that dataset and then cleanup after. Hybrid Create QSAM Hybrid Create VSAM Zowe Only QSAM The Hybrid methods use a combination of JCL and Zowe commands to create, upload into and delete datasets. The Zowe Only method uses only Zowe commands to create, upload into and delete datasets. Intialize a Project This demonstrates a method to create and delete a series of PDSs that could be used for a new Project. Simple Report This demonstrates a possible workflow to create a Project. Create a series of PDSs Upload COBOL and copylib Members and test data Datasets Compile, Link and Run the program Run the program Delete the Project","title":"Get Started with Zowe"},{"location":"guides/zowe-info/getting-started/#dsc-zow-get-started-get-started-using-zowe","text":"Important NOTE 1 A HLQ of ZAAAAA is used in all the example JCL and scripts. You must change that to your TSO userid for these to work. Important NOTE 2 The JCL contained in these examples is written for the system it was run on. You must verify that the parameters used are valid for the system you are running on.","title":"dsc-zow-Get-Started: Get Started using Zowe"},{"location":"guides/zowe-info/getting-started/#the-3-directories","text":"Create Test Dataset Initialize A Project Simple Report","title":"The 3 directories"},{"location":"guides/zowe-info/getting-started/#create-test-dataset","text":"This demonstrates 3 different ways to create a dataset and then upload the data to that dataset and then cleanup after. Hybrid Create QSAM Hybrid Create VSAM Zowe Only QSAM The Hybrid methods use a combination of JCL and Zowe commands to create, upload into and delete datasets. The Zowe Only method uses only Zowe commands to create, upload into and delete datasets.","title":"Create Test Dataset"},{"location":"guides/zowe-info/getting-started/#intialize-a-project","text":"This demonstrates a method to create and delete a series of PDSs that could be used for a new Project.","title":"Intialize a Project"},{"location":"guides/zowe-info/getting-started/#simple-report","text":"This demonstrates a possible workflow to create a Project. Create a series of PDSs Upload COBOL and copylib Members and test data Datasets Compile, Link and Run the program Run the program Delete the Project","title":"Simple Report"},{"location":"guides/zowe-info/install-zowe/","text":"Using the Zowe components Accessing a Mainframe The Mainframe you are accessing must be setup to allow Zowe to connect to it. This is typically done with Z/OSMF. Then RACF permissions need to be granted to your userid to access Z/OSMF. Talk to the Mainframe System Administrator to find out if this is setup and if you have permission. Installing Zowe components As a \"base\", there are two components that should be installed: Zowe Explorer extension for VSCodium (or VSCode) Zowe CLI Zowe Explorer extension for VSCodium (or VSCode) This is a two for one deal. Chose either IBM Z Open Editor or Code4Z (but do not have both enabled at the same time. It might be \"safer\" to only have one installed.) When you install your choice, it will also install Zowe Explorer. For either choice, a Java JDK will also need to be installed. For Pop!_OS: sudo apt install default-jdk Zowe CLI You must have NodeJS and NPM installed. There are numerous ways to install this. Search the Web. Within this VM, I installed NVM , then used that to install the latest LTS: nvm install --lts To install Zowe CLI, follow the Installing Zowe CLI instructions. shortcut For Pop!_OS: npm install -g prebuild-install npm install -g @zowe/cli@zowe-v2-lts Setup a Profile You will need information from the System Administrator for the parameters you need to connect to the Mainframe. These include: IP Address and Port Accept or Reject self-signed certificates protocol used and maybe other parameters The Profile can be created either through the Zowe Explorer interface or through the Zowe CLI interface. The information you get from the System Administrator should contain the instructions on how to do this.","title":"Install Zowe"},{"location":"guides/zowe-info/install-zowe/#using-the-zowe-components","text":"","title":"Using the Zowe components"},{"location":"guides/zowe-info/install-zowe/#accessing-a-mainframe","text":"The Mainframe you are accessing must be setup to allow Zowe to connect to it. This is typically done with Z/OSMF. Then RACF permissions need to be granted to your userid to access Z/OSMF. Talk to the Mainframe System Administrator to find out if this is setup and if you have permission.","title":"Accessing a Mainframe"},{"location":"guides/zowe-info/install-zowe/#installing-zowe-components","text":"As a \"base\", there are two components that should be installed: Zowe Explorer extension for VSCodium (or VSCode) Zowe CLI","title":"Installing Zowe components"},{"location":"guides/zowe-info/install-zowe/#zowe-explorer-extension-for-vscodium-or-vscode","text":"This is a two for one deal. Chose either IBM Z Open Editor or Code4Z (but do not have both enabled at the same time. It might be \"safer\" to only have one installed.) When you install your choice, it will also install Zowe Explorer. For either choice, a Java JDK will also need to be installed. For Pop!_OS: sudo apt install default-jdk","title":"Zowe Explorer extension for VSCodium (or VSCode)"},{"location":"guides/zowe-info/install-zowe/#zowe-cli","text":"You must have NodeJS and NPM installed. There are numerous ways to install this. Search the Web. Within this VM, I installed NVM , then used that to install the latest LTS: nvm install --lts To install Zowe CLI, follow the Installing Zowe CLI instructions.","title":"Zowe CLI"},{"location":"guides/zowe-info/install-zowe/#shortcut","text":"For Pop!_OS: npm install -g prebuild-install npm install -g @zowe/cli@zowe-v2-lts","title":"shortcut"},{"location":"guides/zowe-info/install-zowe/#setup-a-profile","text":"You will need information from the System Administrator for the parameters you need to connect to the Mainframe. These include: IP Address and Port Accept or Reject self-signed certificates protocol used and maybe other parameters The Profile can be created either through the Zowe Explorer interface or through the Zowe CLI interface. The information you get from the System Administrator should contain the instructions on how to do this.","title":"Setup a Profile"}]}